
SegmentedAVISource / SegmentedDirectShowSource
==============================================

| ``SegmentedAVISource`` (string base_filename [, ...], bool "audio", string
  "pixel_type")
| ``SegmentedDirectShowSource`` (string base_filename [, ...], float "fps",
  bool "seek", bool "audio", bool "video", bool "convertfps", bool "seekzero",
  int "timeout", string "pixel_type")

The ``SegmentedAVISource`` filter automatically loads up to 100 avi files per
argument (using :doc:`AVISource <avisource>`) and splices them together (using
:doc:`UnalignedSplice <splice>`). If ``"d:\filename.ext"`` is passed as an argument, the
files ``d:\filename.00.ext``, ``d:\filename.01.ext`` and so on through
``d:\filename.99.ext`` will be loaded. Any files in this sequence that don't
exist will be skipped.

If segments are spanned across multiple drives/folders, they can be loaded
provided the folders are sorted in the correct order. For example

::

    # D:\t1 contains cap.01.avi
    D:\t1\cap.01.avi

    # D:\t2 contains cap.02.avi - cap.03.avi
    D:\t2\cap.02.avi
    D:\t2\cap.03.avi

    # F:\t3 contains cap.04.avi - cap.05.avi
    F:\t3\cap.04.avi
    F:\t3\cap.05.avi

::

    # load all segments
    SegmentedAVISource("D:\t1\cap.avi", "D:\t2\cap.avi", "F:\t3\cap.avi")

``SegmentedDirectShowSource`` works the same way. Its arguments are described
in :doc:`DirectShowSource <directshowsource>`.

From *v2.04* up there is built-in support for ACM (Audio Compression Manager)
audio (e.g. mp3-AVIs).

If you get an Unrecognized Exception in AviSynth 2.5 while reading a
segmented avi generated by a VirtualDub capture, delete the small final .avi
file.

$Date: 2008/02/10 13:57:17 $
