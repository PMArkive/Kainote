<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type" />
<link rel="STYLESHEET" href="filtersdk.css" type="text/css" />
<title>DualPlugins - AviSynth</title></head>
<body><h1><span style="text-decoration: none;">DualPlugins</span></h1>

<div id="body"><p>There are three ways to make dual plugins. That is 2.6 plugins
(compiled with plugin api v5) that also work with AviSynth 2.5. They are
 described here below.
</p>
<table style="width: 275px; height: 149px;" id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h1>Contents</h1><span class="toctoggle"></span></div>
<ul><li class="toclevel-1 tocsection-1"><a href="#The_InvertNeg_example"><span class="tocnumber">1</span> <span class="toctext">The InvertNeg example</span></a>
<ul><li class="toclevel-2 tocsection-2"><a href="#Brute_force_solution_one"><span class="tocnumber">1.1</span> <span class="toctext">Brute force solution one</span></a></li><li class="toclevel-2 tocsection-3"><a href="#Brute_force_solution_two"><span class="tocnumber">1.2</span> <span class="toctext">Brute force solution two</span></a></li><li class="toclevel-2 tocsection-4"><a href="#xxx"><span class="tocnumber">1.3</span> <span class="toctext">xxx</span></a></li></ul>
</li><li class="toclevel-1 tocsection-5"><a href="#The_SimpleSample_example"><span class="tocnumber">2</span> <span class="toctext">The SimpleSample example</span></a></li></ul>
</td></tr></tbody></table>
<h2><span class="editsection"></span><span class="mw-headline" id="The_InvertNeg_example">&nbsp;The InvertNeg example </span></h2>
<p>For InvertNeg it's straightforward to make it as a dual plugin, since
 the code uses the 2.5 feature set. When using the 2.5+ feature set it
becomes more elaborate (and it might not always be possible). See
Simplesample for such an example.
</p>
<h3><span class="editsection"></span><span class="mw-headline" id="Brute_force_solution_one">&nbsp;Brute force solution one </span></h3>
<p>This solution doubles all the code. You need to rename avisynth.h
(v3) to avisynth25.h and avisynth.h (v5) to avisynth26.h and add them
both to your project. You also need to add the following two source
files to your project:
</p>
<pre>/* InvertNeg25.cpp */<br /><br />#include &lt;windows.h&gt;<br />#include "avisynth25.h"<br /><br />class InvertNeg25&nbsp;: public GenericVideoFilter {<br />public:<br />   InvertNeg25(PClip _child, IScriptEnvironment* env);<br />   PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env);<br />};<br /><br />InvertNeg25::InvertNeg25(PClip _child, IScriptEnvironment* env)&nbsp;:<br />   GenericVideoFilter(_child) {<br />   if (!vi.IsPlanar() ||&nbsp;!vi.IsYUV()) {<br />      env-&gt;ThrowError("InvertNeg: planar YUV data only!");<br />   }<br />}<br /><br />PVideoFrame __stdcall InvertNeg25::GetFrame(int n, IScriptEnvironment* env) {<br /><br />   PVideoFrame src = child-&gt;GetFrame(n, env);<br />   PVideoFrame dst = env-&gt;NewVideoFrame(vi);<br /><br />   const unsigned char* srcp;<br />   unsigned char* dstp;<br />   int src_pitch, dst_pitch, row_size, height;<br />   int p, x, y;<br /><br />   int planes[] = {PLANAR_Y, PLANAR_V, PLANAR_U};<br />	<br />   for (p=0; p&lt;3; p++) {<br />      srcp = src-&gt;GetReadPtr(planes[p]);<br />      dstp = dst-&gt;GetWritePtr(planes[p]);<br /><br />      src_pitch = src-&gt;GetPitch(planes[p]);<br />      dst_pitch = dst-&gt;GetPitch(planes[p]);<br />      row_size = dst-&gt;GetRowSize(planes[p]);<br />      height = dst-&gt;GetHeight(planes[p]);<br /><br />      for (y = 0; y &lt; height; y++) {<br />         for (x = 0; x &lt; row_size; x++) {<br />            dstp[x] = srcp[x] ^ 255;<br />         }<br />         srcp += src_pitch;<br />         dstp += dst_pitch;<br />      }<br />   }<br />   return dst;<br />}<br /><br />AVSValue __cdecl Create_InvertNeg25(AVSValue args, void* user_data, IScriptEnvironment* env) {<br />   return new InvertNeg25(args[0].AsClip(), env);<br />}<br /><br />extern "C" __declspec(dllexport) const char* __stdcall AvisynthPluginInit2(IScriptEnvironment* env) {<br />   env-&gt;AddFunction("InvertNeg", "c", Create_InvertNeg25, 0);<br />   return "InvertNeg sample plugin";<br />}<br /></pre>
<pre>/* InvertNeg26.cpp */<br /><br />#include &lt;windows.h&gt;<br />#include "avisynth26.h"<br /><br />class InvertNeg26&nbsp;: public GenericVideoFilter {<br />public:<br />   InvertNeg26(PClip _child, IScriptEnvironment* env);<br />   PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env);<br />};<br /><br />InvertNeg26::InvertNeg26(PClip _child, IScriptEnvironment* env)&nbsp;:<br />   GenericVideoFilter(_child) {<br />   if (!vi.IsPlanar() ||&nbsp;!vi.IsYUV()) {<br />      env-&gt;ThrowError("InvertNeg: planar YUV data only!");<br />   }<br />}<br /><br />PVideoFrame __stdcall InvertNeg26::GetFrame(int n, IScriptEnvironment* env) {<br /><br />   PVideoFrame src = child-&gt;GetFrame(n, env);<br />   PVideoFrame dst = env-&gt;NewVideoFrame(vi);<br /><br />   const unsigned char* srcp;<br />   unsigned char* dstp;<br />   int src_pitch, dst_pitch, row_size, height;<br />   int p, x, y;<br /><br />   int planes[] = {PLANAR_Y, PLANAR_V, PLANAR_U};<br />	<br />   for (p=0; p&lt;3; p++) {<br />      srcp = src-&gt;GetReadPtr(planes[p]);<br />      dstp = dst-&gt;GetWritePtr(planes[p]);<br /><br />      src_pitch = src-&gt;GetPitch(planes[p]);<br />      dst_pitch = dst-&gt;GetPitch(planes[p]);<br />      row_size = dst-&gt;GetRowSize(planes[p]);<br />      height = dst-&gt;GetHeight(planes[p]);<br /><br />      for (y = 0; y &lt; height; y++) {<br />         for (x = 0; x &lt; row_size; x++) {<br />            dstp[x] = srcp[x] ^ 255;<br />         }<br />         srcp += src_pitch;<br />         dstp += dst_pitch;<br />      }<br />   }<br />   return dst;<br />}<br /><br />AVSValue __cdecl Create_InvertNeg26(AVSValue args, void* user_data, IScriptEnvironment* env) {<br />   return new InvertNeg26(args[0].AsClip(), env);<br />}<br /><br />const AVS_Linkage *AVS_linkage = 0;<br /><br />extern "C" __declspec(dllexport) const char* __stdcall AvisynthPluginInit3(IScriptEnvironment* env, const AVS_Linkage* const vectors) {<br />   AVS_linkage = vectors;<br />   env-&gt;AddFunction("InvertNeg", "c", Create_InvertNeg26, 0);<br />   return "InvertNeg sample plugin";<br />}<br /></pre>
<p>Note that both functions Create_InvertNeg25 and Create_InvertNeg26
are added in the function table (by AddFunction) as InvertNeg. Which one
 is called by your script will be decided by the AvisynthPluginInit2 and
 AvisynthPluginInit3 entry points (and thus your AviSynth version).
</p><p>Compile both files into a DLL named InvertNeg.dll. See <a href="CompilingAvisynthPlugins.htm" title="Filter SDK/Compiling instructions">compiling instructions</a>. Now create an AviSynth script which looks something like this:
</p>
<pre>LoadPlugin("d:\path\InvertNeg.dll")<br />clip = BlankClip().ConvertToYV12()<br />return clip.InvertNeg()<br /></pre>
<p>The script should work both for AviSynth 2.5 and 2.6.
</p>
<h3><span class="editsection"></span><span class="mw-headline" id="Brute_force_solution_two">&nbsp;Brute force solution two </span></h3>
<p>To stop having to double your source code you could use the namespace trick the 2.0 import wrapper uses.
</p><p>Place all the filter generic code into a separate file,
"InvertNeg.hpp", and #include it twice. Technically you have two copies
of everything binary, but only a single source code. Note: outside the
namespace you uniquely access object names as avs25::name or
avs26::name.
</p>
<pre>/* InvertNeg.cpp */<br /><br />#include &lt;windows.h&gt;<br /><br />namespace avs25 {<br />   #include "avisynth25.h"<br />   #include "InvertNeg.hpp"<br />}<br /> <br />#undef __AVISYNTH_H__ // name must not be included twice in the inclusions<br /><br />namespace avs26 {<br />   #include "avisynth26.h"<br />   const AVS_Linkage *AVS_linkage = 0;<br />   #include "InvertNeg.hpp"<br />}<br /><br />extern "C" __declspec(dllexport) const char* __stdcall AvisynthPluginInit2(avs25::IScriptEnvironment* env) {<br />   env-&gt;AddFunction("InvertNeg", "c", avs25::Create_InvertNeg, 0);<br />   return "InvertNeg sample plugin";<br />}<br /><br />extern "C" __declspec(dllexport) const char* __stdcall AvisynthPluginInit3(avs26::IScriptEnvironment* env, const avs26::AVS_Linkage* const vectors) {<br />   avs26::AVS_linkage = vectors;<br />   env-&gt;AddFunction("InvertNeg", "c", avs26::Create_InvertNeg, 0);<br />   return "InvertNeg sample plugin";<br />}<br /></pre>
<pre>/* InvertNeg.hpp */<br /><br />class InvertNeg&nbsp;: public GenericVideoFilter {<br />public:<br />   InvertNeg(PClip _child, IScriptEnvironment* env);<br />   PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env);<br />};<br /><br />InvertNeg::InvertNeg(PClip _child, IScriptEnvironment* env)&nbsp;:<br />   GenericVideoFilter(_child) {<br />   if (!vi.IsPlanar() ||&nbsp;!vi.IsYUV()) {<br />      env-&gt;ThrowError("InvertNeg: planar YUV data only!");<br />   }<br />}<br /><br />PVideoFrame __stdcall InvertNeg::GetFrame(int n, IScriptEnvironment* env) {<br /><br />   PVideoFrame src = child-&gt;GetFrame(n, env);<br />   PVideoFrame dst = env-&gt;NewVideoFrame(vi);<br /><br />   const unsigned char* srcp;<br />   unsigned char* dstp;<br />   int src_pitch, dst_pitch, row_size, height;<br />   int p, x, y;<br /><br />   int planes[] = {PLANAR_Y, PLANAR_V, PLANAR_U};<br />	<br />   for (p=0; p&lt;3; p++) {<br />      srcp = src-&gt;GetReadPtr(planes[p]);<br />      dstp = dst-&gt;GetWritePtr(planes[p]);<br /><br />      src_pitch = src-&gt;GetPitch(planes[p]);<br />      dst_pitch = dst-&gt;GetPitch(planes[p]);<br />      row_size = dst-&gt;GetRowSize(planes[p]);<br />      height = dst-&gt;GetHeight(planes[p]);<br /><br />      for (y = 0; y &lt; height; y++) {<br />         for (x = 0; x &lt; row_size; x++) {<br />            dstp[x] = srcp[x] ^ 255;<br />         }<br />         srcp += src_pitch;<br />         dstp += dst_pitch;<br />      }<br />   }<br />   return dst;<br />}<br /><br />AVSValue __cdecl Create_InvertNeg(AVSValue args, void* user_data, IScriptEnvironment* env) {<br />   return new InvertNeg(args[0].AsClip(), env);<br />}<br /></pre>
<p>Compile this file into a DLL named InvertNeg.dll. See <a href="CompilingAvisynthPlugins.htm" title="Filter SDK/Compiling instructions">compiling instructions</a>. Now create an AviSynth script which looks something like this:
</p>
<pre>LoadPlugin("d:\path\InvertNeg.dll")<br />clip = BlankClip().ConvertToYV12()<br />return clip.InvertNeg()<br /></pre>
<h3><span class="editsection"></span><span class="mw-headline" id="xxx">&nbsp;xxx </span></h3>
<p><a rel="nofollow" class="external free" href="http://forum.doom9.org/showthread.php?p=1641346#post1641346">http://forum.doom9.org/showthread.php?p=1641346#post1641346</a> and subsequent posts ....
</p>
<h2><span class="editsection"></span><span class="mw-headline" id="The_SimpleSample_example">&nbsp;The SimpleSample example </span></h2>
<p>The SimpleSample code uses the 2.5+ feature set, since it uses
GetPlaneWidthSubsampling and GetPlaneHeightSubsampling. These are
functions of <a href="VideoInfo.htm" title="Cplusplus API/VideoInfo">VideoInfo</a>. One way to get it to work is to add these functions in avisynth25.h in the <a href="VideoInfo.htm" title="Cplusplus API/VideoInfo">VideoInfo</a> structure. Note that in this case they are only used for YV12:
</p>
<pre>/* avisynth25.h */<br /><br />struct VideoInfo {<br />  ...<br />  // mimics 2.6 functionality for YV12<br />  int GetPlaneWidthSubsampling(int plane) const {<br />    switch(plane) {<br />    case PLANAR_Y:<br />      return 0;<br />    case PLANAR_U:<br />      return 1;<br />    case PLANAR_V:<br />      return 1;<br />    default:<br />      return 0;<br />    }<br />  }<br />  <br />  int GetPlaneHeightSubsampling(int plane) const {<br />    switch(plane) {<br />    case PLANAR_Y:<br />      return 0;<br />    case PLANAR_U:<br />      return 1;<br />    case PLANAR_V:<br />      return 1;<br />    default:<br />      return 0;<br />    }<br />  }<br />};<br /></pre>
<p>Now we can place all the filter generic code into a separate file,
"simplesample.hpp", #include it twice, and access object names as
avs25::name or avs26::name.
</p>
<pre>/* simplesample.cpp */<br /><br />/*<br />	SimpleSample plugin for Avisynth -- a simple sample<br /><br />	Copyright (C) 2002-2013 Simon Walters, Wilbert Dijkhof, All Rights Reserved<br /><br />	This program is free software; you can redistribute it and/or modify<br />	it under the terms of the GNU General Public License as published by<br />	the Free Software Foundation.<br /><br />	This program is distributed in the hope that it will be useful,<br />	but WITHOUT ANY WARRANTY; without even the implied warranty of<br />	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the<br />	GNU General Public License for more details.<br /><br />	You should have received a copy of the GNU General Public License<br />	along with this program; if not, write to the Free Software<br />	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.<br /><br />	The author can be contacted at:<br />	wilbertdijkhof at yahoo.com<br /><br />	v2.0 - AviSynth 2.6 api (based on v1.6 of Simon Walters)<br />	v2.1 - Dual plugin for 2.5 and 2.6<br />*/<br /><br />#include &lt;windows.h&gt;<br /><br />namespace avs25 {<br />  #include "avisynth25.h"<br />  #include "simplesample.hpp"<br />}<br /> <br />#undef __AVISYNTH_H__ // name must not be included twice in the inclusions<br /><br />namespace avs26 {<br />  #include "avisynth26.h"<br />  const AVS_Linkage *AVS_linkage = 0;<br />  #include "simplesample.hpp"<br />}<br /><br />extern "C" __declspec(dllexport) const char* __stdcall AvisynthPluginInit2(avs25::IScriptEnvironment* env) {<br />  env-&gt;AddFunction("SimpleSample", "c[size]i", avs25::Create_SimpleSample, 0);<br />  return "SimpleSample plugin";<br />}<br /><br />extern "C" __declspec(dllexport) const char* __stdcall AvisynthPluginInit3(avs26::IScriptEnvironment* env, const avs26::AVS_Linkage* const vectors) {<br />  avs26::AVS_linkage = vectors;<br />  env-&gt;AddFunction("SimpleSample", "c[size]i", avs26::Create_SimpleSample, 0);<br />  return "SimpleSample plugin";<br />}<br /></pre>
<p><br />
</p>
<pre>/* simplesample.hpp */<br /><br />class SimpleSample&nbsp;: public GenericVideoFilter {<br />   int SquareSize;<br />public:<br />   SimpleSample(PClip _child, int _SquareSize, IScriptEnvironment* env);<br />   ~SimpleSample();<br />   PVideoFrame __stdcall GetFrame(int n, IScriptEnvironment* env);<br />};<br /><br />SimpleSample::SimpleSample(PClip _child, int _SquareSize, IScriptEnvironment* env)&nbsp;:<br />   GenericVideoFilter(_child), SquareSize(_SquareSize) {<br />   if (vi.width&lt;SquareSize || vi.height&lt;SquareSize) {<br />      env-&gt;ThrowError("SimpleSample: square doesn't fit into the clip!");<br />   }<br />}<br /><br />SimpleSample::~SimpleSample() {}<br /><br />PVideoFrame __stdcall SimpleSample::GetFrame(int n, IScriptEnvironment* env) {<br /><br />   PVideoFrame src = child-&gt;GetFrame(n, env);<br />   env-&gt;MakeWritable(&amp;src);<br /><br />   unsigned char* srcp = src-&gt;GetWritePtr();<br />   int src_pitch = src-&gt;GetPitch();<br />   int src_width = src-&gt;GetRowSize();<br />   int src_height = src-&gt;GetHeight();<br /><br />   int w, h, woffset;<br /><br />   if (vi.IsRGB24()) {<br />      srcp = srcp + (src_height/2 - SquareSize/2) * src_pitch;<br /><br />      woffset = src_width/2 - 3*SquareSize/2;<br /><br />      for (h=0; h&lt;SquareSize; h++) {<br />         for (w=0; w&lt;3*SquareSize; w+=3) {<br />            *(srcp + woffset + w) = 255;<br />            *(srcp + woffset + w + 1) = 255;<br />            *(srcp + woffset + w + 2) = 255;<br />         }															<br />         srcp += src_pitch;<br />      }<br />   }<br />   if (vi.IsRGB32()) {<br />      srcp = srcp + (src_height/2 - SquareSize/2) * src_pitch;<br /><br />      woffset = src_width/2 - 4*SquareSize/2;<br /><br />      for (h=0; h&lt;SquareSize; h++) {<br />         for (w=0; w&lt;4*SquareSize; w+=4) {<br />            *(srcp + woffset + w) = 255;<br />            *(srcp + woffset + w + 1) = 255;<br />            *(srcp + woffset + w + 2) = 255;<br />         }<br />         srcp += src_pitch;<br />      }<br />   }<br />/*<br />   if (vi.IsRGB32()) { // variant 1 - processing a pixel at once<br />      srcp = srcp + (src_height/2 - SquareSize/2) * src_pitch;<br /><br />      woffset = src_width/8 - SquareSize/2;<br /><br />      for (h=0; h&lt;SquareSize; h++) {<br />         for (w=0; w&lt;SquareSize; w++) {<br />            *((unsigned int *)srcp + woffset + w) = 0x00FFFFFF;<br />         }	<br />         srcp += src_pitch;<br />      }<br />   }<br />*/<br />/*<br />   if (vi.IsRGB32()) { // variant 2 - processing a pixel at once<br />      unsigned int* srcp = (unsigned int*)src-&gt;GetWritePtr();<br />	<br />      srcp = srcp + (src_height/2 - SquareSize/2) * src_pitch/4;<br /><br />      woffset = src_width/8 - SquareSize/2;<br /><br />      for (h=0; h&lt;SquareSize; h++) {<br />         for (w=0; w&lt;SquareSize; w++) {<br />            srcp[woffset + w] = 0x00FFFFFF;<br />         }	<br />         srcp += src_pitch/4;<br />      }<br />   }<br />*/<br />   if (vi.IsYUY2()) {<br />      srcp = srcp + (src_height/2 - SquareSize/2) * src_pitch;<br /><br />      woffset = src_width/8 - SquareSize/4;<br /><br />      for (h=0; h&lt;SquareSize; h++) {<br />         for (w=0; w&lt;SquareSize/2; w++) {<br />            *((unsigned int *)srcp + woffset + w) = 0x80EB80EB;<br />         }<br />         srcp += src_pitch; <br />      }<br />   }<br />   if (vi.IsPlanar() &amp;&amp; vi.IsYUV()) {<br /><br />      int planes[] = {PLANAR_Y, PLANAR_U, PLANAR_V};<br />      int square_value[] = {235, 128, 128};<br />      int p;<br />      int width_sub, height_sub;<br /><br />      for (p=0; p&lt;3; p++) {<br />         srcp = src-&gt;GetWritePtr(planes[p]);		<br />         src_pitch = src-&gt;GetPitch(planes[p]);<br />         src_width = src-&gt;GetRowSize(planes[p]);<br />         src_height = src-&gt;GetHeight(planes[p]);<br />         width_sub = vi.GetPlaneWidthSubsampling(planes[p]);<br />         height_sub = vi.GetPlaneHeightSubsampling(planes[p]);<br /><br />         srcp = srcp + (src_height/2 - (SquareSize&gt;&gt;height_sub)/2) * src_pitch;<br /><br />         woffset = src_width/2 - (SquareSize&gt;&gt;width_sub)/2;<br /><br />         for (h=0; h&lt;(SquareSize&gt;&gt;height_sub); h++) {<br />            for (w=0; w&lt;(SquareSize&gt;&gt;width_sub); w++) {<br />               srcp[woffset + w] = square_value[p];<br />            }<br />            srcp += src_pitch;<br />         }<br />      }<br />   }<br /><br />   return src;<br />}<br /><br />AVSValue __cdecl Create_SimpleSample(AVSValue args, void* user_data, IScriptEnvironment* env) {<br />   return new SimpleSample(args[0].AsClip(),   <br />                           args[1].AsInt(100),<br />                           env); <br />}<br /></pre>
<p>Compile this file into a DLL named SimpleSample.dll. See <a href="CompilingAvisynthPlugins.htm" title="Filter SDK/Compiling instructions">compiling instructions</a>. Now create an Avisynth script which looks something like this:
</p>
<pre>LoadPlugin("d:\path\simplesample.dll")<br />Colorbars().Trim(0,1)<br />ConvertToYV12()<br /># ConvertToYV411() # requires AviSynth 2.6<br />SimpleSample(100)<br /></pre><hr style="width: 100%; height: 2px;" />Back to&nbsp;<a href="FilterSDK.htm">FilterSDK</a></div>
<p><kbd>$Date: 2014/10/27 22:04:54 $</kbd></p>
</body></html>