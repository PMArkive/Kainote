//  Copyright (c) 2016, Marcin Drob

//  Kainote is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.

//  Kainote is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.

//  You should have received a copy of the GNU General Public License
//  along with Kainote.  If not, see <http://www.gnu.org/licenses/>.

#include "SubsGrid.h"

<<<<<<< HEAD
=======
#include "SubsGrid.h"
#include "config.h"
#include "EditBox.h"

#include "kainoteMain.h"
#include "OpennWrite.h"
#include "OptionsDialog.h"
#include "Tabs.h"
#include <wx/tokenzr.h>
#include <wx/event.h>
#include <algorithm>
#include <wx/regex.h>
#include <wx/ffile.h>
#include "KaiMessageBox.h"
#include <thread>

bool sortstart(Dialogue *i,Dialogue *j){ 
	if(i->Start.mstime!=j->Start.mstime){
		return (i->Start.mstime<j->Start.mstime);
	}
	return i->End.mstime<j->End.mstime;
}
bool sortend(Dialogue *i,Dialogue *j){
	if(i->End.mstime!=j->End.mstime){
		return (i->End.mstime<j->End.mstime);
	}
	return i->Start.mstime<j->Start.mstime;
}
bool sortstyle(Dialogue *i,Dialogue *j){
	if(i->Style!=j->Style){
		return (i->Style.CmpNoCase(j->Style)<0); 
	}
	return i->Start.mstime<j->Start.mstime;
}
bool sortactor(Dialogue *i,Dialogue *j){
	if(i->Actor!=j->Actor){
		return (i->Actor.CmpNoCase(j->Actor)<0); 
	}
	return i->Start.mstime<j->Start.mstime;
}
bool sorteffect(Dialogue *i,Dialogue *j){ 
	if(i->Effect!=j->Effect){
		return (i->Effect.CmpNoCase(j->Effect)<0); 
	}
	return i->Start.mstime<j->Start.mstime;
}
bool sortlayer(Dialogue *i,Dialogue *j){
	if(i->Layer!=j->Layer){
		return (i->Layer<j->Layer); 
	}
	return i->Start.mstime<j->Start.mstime;
}

bool SubsGrid::IsNum(const wxString &test) {
	bool isnumber=true;
	wxString testchars="0123456789";
	for(size_t i=0;i<test.Len();i++){
		wxUniChar ch=test.GetChar(i);
		if(testchars.Find(ch)==-1){isnumber=false;break;}
	}
	return isnumber;
}



SubsGrid::SubsGrid(wxWindow *parent, const long int id,const wxPoint& pos,const wxSize& size, long style, const wxString& name)
	: KaiScrolledWindow(parent, id, pos, size, style|wxVERTICAL, name)
{
	posY=0;
	posX=0;
	row=markedLine=lastActiveLine=0;
	scPos=0;
	scHor=0;
	oldX=-1;
	visible=Options.GetInt(GridHideCollums);
	holding = false;
	hideover=Options.GetBool(GridHideTags);
	Modified=false;
	first=true;
	makebkp=true;
	extendRow=-1;
	lastRow=0;
	lastsel=-1;
	transl=false;
	showtl=false;
	ismenushown=false;
	showFrames=false;
	Comparison=NULL;
	bmp=NULL;
	numsave=0;
	file=new SubsFile();


	LoadDefault();
	timer.SetOwner(this,ID_AUTIMER);
	nullifyTimer.SetOwner(this,27890);
	Bind(wxEVT_TIMER,[=](wxTimerEvent &evt){
		Kai->SetStatusText("",0);
	},27890);
	SetStyle();
	AdjustWidths();
}


SubsGrid::~SubsGrid()
{
	Clearing();
	if(bmp){delete bmp;bmp=NULL;}
}

void SubsGrid::SetStyle() 
{
	wxString fontname = Options.GetString(GridFontName);
	font.SetFaceName(fontname);
	if (!font.IsOk())
		font.SetFamily(wxFONTFAMILY_SWISS );
	font.SetWeight(wxFONTWEIGHT_NORMAL);
	font.SetPointSize(Options.GetInt(GridFontSize));

	{
		wxClientDC dc(this);
		dc.SetFont(font);
		int fw,fh;
		dc.GetTextExtent("#TWFfGH", &fw, &fh, NULL, NULL, &font);
		GridHeight=fh+2;
	}


	Refresh(false);
}


void SubsGrid::OnPaint(wxPaintEvent& event)
{

	int w = 0;
	int h = 0;
	GetClientSize(&w,&h);
	bool bg=false;
	int size=GetCount();
	panelrows=(h/(GridHeight+1))+1;
	int scrows=scPos+panelrows;
	//gdy widzimy koniec napisów
	if(scrows >= size + 3){
		bg=true;
		scrows = size + 1;
		scPos=(scrows-panelrows)+2;// dojechanie do końca napisów
		if(panelrows > size + 3){scPos=0;}// w przypadku gdy całe napisy są widoczne, wtedy nie skrollujemy i pozycja =0
	}
	else if(scrows >= size + 2){
		bg=true;
		scrows--;//w przypadku gdy mamy linię przed końcem napisów musimy zaniżyć wynik bo przekroczy tablicę.
	}
	if(SetScrollBar(wxVERTICAL,scPos,panelrows, size + 3, panelrows-3)){
		GetClientSize(&w,&h);
	}

	// Prepare bitmap
	if (bmp) {
		if (bmp->GetWidth() < w+scHor || bmp->GetHeight() < h) {
			delete bmp;
			bmp = NULL;
		}
	}
	if (!bmp) bmp = new wxBitmap(w+scHor,h);

	// Draw bitmap
	wxMemoryDC tdc;
	tdc.SelectObject(*bmp);
	int firstCol = GridWidth[0]+1;



	tdc.SetFont(font);
	//wxMemoryDC tdc;
	//wxBitmap tbmp(w+scHor,h);
	//tdc.SelectObject(tbmp);
	//tdc.SetFont(font);
	wxColour header = Options.GetColour(GridHeader);
	wxColour headerText = Options.GetColour(GridHeaderText);
	wxColour labelBkCol=Options.GetColour(GridLabelSaved);
	wxColour labelBkColN=Options.GetColour(GridLabelNormal);
	wxColour labelBkColM=Options.GetColour(GridLabelModified);
	wxColour labelBkColD=Options.GetColour(GridLabelDoubtful);
	wxColour linesCol=Options.GetColour(GridLines);
	wxColour subsBkCol=Options.GetColour(GridDialogue);
	wxColour comm=Options.GetColour(GridComment);
	wxColour seldial=Options.GetColour(GridSelectedDialogue);
	wxColour selcom=Options.GetColour(GridSelectedComment);
	wxColour textcol=Options.GetColour(GridText);
	wxColour collcol=Options.GetColour(GridCollisions);
	wxColour SpelcheckerCol=Options.GetColour(GridSpellchecker);
	wxColour ComparisonCol=Options.GetColour(GridComparison);
	wxColour ComparisonBGCol=Options.GetColour(GridComparisonBackground);
	wxColour ComparisonBGSelCol=Options.GetColour(GridComparisonBackgroundSelected);
	wxColour ComparisonBGCmntCol=Options.GetColour(GridComparisonCommentBackground);
	wxColour ComparisonBGCmntSelCol=Options.GetColour(GridComparisonCommentBackgroundSelected);
	wxString chtag=Options.GetString(GridTagsSwapChar);
	wxColour visibleOnVideo = Options.GetColour(GridVisibleOnVideo);
	bool SpellCheckerOn = Options.GetBool(SpellcheckerOn);

	tdc.SetPen(*wxTRANSPARENT_PEN);
	tdc.SetBrush(wxBrush(linesCol));
	tdc.DrawRectangle(0,0,w+scHor/*-(GridWidth[0]+1)*/,h);

	int ilcol;
	posY=0;

	bool isComment=false;
	bool unkstyle=false;
	bool shorttime=false;
	int states=0;

	if(SpellErrors.size()<(size_t)size){
		SpellErrors.resize(size);
	}

	Dialogue *acdial=GetDial(MID(0,Edit->ebrow,size-1));
	Dialogue *Dial;
	TabPanel *tab = (TabPanel*)GetParent();
	int VideoPos = tab->Video->Tell();

	int fw,fh,bfw,bfh;
	wxColour kol;
	visibleLines.clear();
	

	for(int i=scPos;i<scrows;i++){

		wxArrayString strings;
		bool comparison = false;
		bool isSelected = false;

		if (i==scPos){
			strings.Add("#");
			if (form<SRT){
				strings.Add(_("W."));
			}
			strings.Add(_("Start"));
			if (form!=TMP){
				strings.Add(_("Koniec"));
			}
			if (form<SRT){
				strings.Add(_("Styl"));
				strings.Add(_("Aktor"));
				strings.Add(_("M.L."));
				strings.Add(_("M.P."));
				strings.Add(_("M.Pi."));
				strings.Add(_("Efekt"));
			}
			if(form!=TMP){strings.Add(_("ZNS"));}
			strings.Add(showtl? _("Tekst oryginalny") : _("Tekst"));
			if(showtl){strings.Add(_("Tekst tłumaczenia"));}
			kol = header;
		}else{
			Dial=GetDial(i-1);

			strings.Add(wxString::Format("%i",i));

			isComment=Dial->IsComment;
			//gdy zrobisz inaczej niepewne to użyj ^ 4 by wywalić 4 ze state.
			states=Dial->State;
			if (form<SRT){
				strings.Add(wxString::Format("%i",Dial->Layer));
			}
			
			if(showFrames && tab->Video->VFF){
				VideoFfmpeg *VFF = tab->Video->VFF;
				wxString frame;
				frame << VFF->GetFramefromMS(Dial->Start.mstime);
				strings.Add(frame);
				if (form!=TMP){
					frame="";
					frame << VFF->GetFramefromMS(Dial->End.mstime)-1;
					strings.Add(frame);
				}
			}else{
				strings.Add(Dial->Start.raw(form));
				if (form!=TMP){strings.Add(Dial->End.raw(form));}
			}
			
			if (form<SRT){
				if(FindStyle(Dial->Style)==-1){unkstyle=true;}else{unkstyle=false;}
				strings.Add(Dial->Style);
				strings.Add(Dial->Actor);
				strings.Add(wxString::Format("%i",Dial->MarginL));
				strings.Add(wxString::Format("%i",Dial->MarginR));
				strings.Add(wxString::Format("%i",Dial->MarginV));
				strings.Add(Dial->Effect);
			}
			if(form!=TMP && !(CNZ & visible)){
				int chtime;
				if( SpellErrors[i-1].size()<1 ){
					chtime=CalcChars((transl && Dial->TextTl!="")? 
						Dial->TextTl : Dial->Text) / ((Dial->End.mstime-Dial->Start.mstime)/1000.0f);
					if(chtime<0 || chtime>999){chtime=999;}
					SpellErrors[i-1].push_back(chtime);

				}else{ chtime = SpellErrors[i-1][0];}
				strings.Add(wxString::Format("%i",chtime));
				shorttime=chtime>15;
			}else{
				if(form!=TMP){strings.Add("");}
				if(SpellErrors[i-1].size()==0){SpellErrors[i-1].push_back(0);}
			}

			wxString txt=Dial->Text;
			wxString txttl=Dial->TextTl;
			if (hideover){
				wxRegEx reg("\\{[^\\{]*\\}",wxRE_ADVANCED);
				reg.ReplaceAll(&txt,chtag);
				if(showtl){reg.ReplaceAll(&txttl,chtag);}
			}
			if(txt.Len()>1000){txt=txt.SubString(0,1000)+"...";}
			strings.Add((!showtl&&transl&&txttl!="")?txttl : txt);
			if(showtl){strings.Add(txttl);}

			if(SpellCheckerOn && (!transl && Dial->Text!="" || transl && Dial->TextTl!="")){
				if(SpellErrors[i-1].size()<2){
					CheckText(strings[strings.size()-1],SpellErrors[i-1]);
				}
			} 
			if(sel.find(i-1) != sel.end()){
				isSelected = true;
			}
			comparison = (Comparison && Comparison->at(i-1).size()>0);//visibleLines
			bool visibleLine = (Dial->Start.mstime <= VideoPos && Dial->End.mstime > VideoPos);
			kol = (comparison)? ComparisonBGCol : 
				(visibleLine)? visibleOnVideo : 
				subsBkCol;
			if(isComment){kol= (comparison)? ComparisonBGCmntCol : comm;}
			if(isSelected){
				if(isComment){kol = (comparison)? ComparisonBGCmntSelCol : selcom;}
				else{kol= (comparison)? ComparisonBGSelCol : seldial; }
			}
			if(visibleLine){visibleLines.push_back(true);}
			else{visibleLines.push_back(false);}
		}

		posX=0;


		ilcol=strings.GetCount();
		

		wxRect cur;
		bool isCenter;
		wxColour label= (states == 0)? labelBkColN : (states == 2)? labelBkCol : 
			(states == 1)? labelBkColM : labelBkColD;
		for (int j=0; j<ilcol; j++){
			if(showtl&&j==ilcol-2){
				int podz=(w + scHor - posX) / 2;
				GridWidth[j]=podz;
				GridWidth[j+1]=podz;
			}

			if(!showtl&&j==ilcol-1){GridWidth[j] = w + scHor - posX;}
			

			if(GridWidth[j]>0){
				tdc.SetPen(*wxTRANSPARENT_PEN);
				
				tdc.SetBrush(wxBrush((j==0 && i!=scPos)? label : kol));
				if(unkstyle && j==4 || shorttime && (j==10||(j==3 && form>ASS))){
					tdc.SetBrush(wxBrush(SpelcheckerCol));
				}

				tdc.DrawRectangle(posX,posY,GridWidth[j],GridHeight);

				if(i!=scPos && j==ilcol-1){

					if(SpellErrors[i-1].size()>2){
						tdc.SetBrush(wxBrush(SpelcheckerCol));
						for(size_t k = 1; k < SpellErrors[i-1].size(); k+=2){

							wxString err=strings[j].SubString(SpellErrors[i-1][k], SpellErrors[i-1][k+1]);
							err.Trim();
							if(SpellErrors[i-1][k]>0){
								wxString berr=strings[j].Mid(0, SpellErrors[i-1][k]);
								tdc.GetTextExtent(berr, &bfw, &bfh, NULL, NULL, &font);
							}else{bfw=0;}

							tdc.GetTextExtent(err, &fw, &fh, NULL, NULL, &font);
							tdc.DrawRectangle(posX+bfw+3,posY,fw,GridHeight);
						}
					}


					if(comparison){
						tdc.SetTextForeground(ComparisonCol);

						for(size_t k = 1; k < Comparison->at(i-1).size(); k+=2){
							//if(Comparison->at(i-1)[k]==Comparison->at(i-1)[k+1]){continue;}
							wxString cmp=strings[j].SubString(Comparison->at(i-1)[k], Comparison->at(i-1)[k+1]);

							if(cmp==""){continue;}
							if(cmp==" "){cmp="_";}
							wxString bcmp;
							if(Comparison->at(i-1)[k]>0){
								bcmp=strings[j].Mid(0, Comparison->at(i-1)[k]);
								tdc.GetTextExtent(bcmp, &bfw, &bfh, NULL, NULL, &font);
							}else{bfw=0;}

							tdc.GetTextExtent(cmp, &fw, &fh, NULL, NULL, &font);
							if((cmp.StartsWith("T") || cmp.StartsWith("Y") || cmp.StartsWith(L"Ł"))){bfw++;}

							tdc.DrawText(cmp,posX+bfw+2,posY);
							tdc.DrawText(cmp,posX+bfw+4,posY);
							tdc.DrawText(cmp,posX+bfw+2,posY+2);
							tdc.DrawText(cmp,posX+bfw+4,posY+2);
						}

					}

				}


				bool collis=(i!=scPos && i!=Edit->ebrow+1 && 
					(Dial->Start >= acdial->Start && Dial->Start < acdial->End || 
					Dial->End > acdial->Start && Dial->Start <= acdial->End)); 

				if(form<SRT){isCenter=!(j == 4 || j == 5 || j == 9 || j == 11 || j == 12);}
				else if(form==TMP){isCenter=!(j == 2);}
				else{isCenter=!(j == 4);}

				tdc.SetTextForeground((i == scPos)? headerText : (collis)? collcol : textcol);
				if(j==ilcol-1 && (strings[j].StartsWith("T") || strings[j].StartsWith("Y") || strings[j].StartsWith(L"Ł"))){posX++;}
				cur = wxRect(posX+3,posY,GridWidth[j]-6,GridHeight);
				tdc.SetClippingRegion(cur);
				tdc.DrawLabel(strings[j], cur, isCenter ? wxALIGN_CENTER : (wxALIGN_CENTER_VERTICAL | wxALIGN_LEFT));
				tdc.DestroyClippingRegion();

				posX+=GridWidth[j]+1;

			}
		}

		posY+=GridHeight+1;

	}


	if(bg){
		tdc.SetPen(*wxTRANSPARENT_PEN);
		tdc.SetBrush(wxBrush(Options.GetColour(GridBackground)));
		tdc.DrawRectangle(0,posY,w+scHor,h);
	}
	if(markedLine>=scPos&&markedLine<=scrows){
		tdc.SetBrush(*wxTRANSPARENT_BRUSH);
		tdc.SetPen(wxPen(Options.GetColour(GridActiveLine),3));
		tdc.DrawRectangle(1,((markedLine-scPos+1)*(GridHeight+1))-1,(GridWidth[0]-1),GridHeight+2);
	}

	if(Edit->ebrow>=scPos&&Edit->ebrow<=scrows){
		tdc.SetBrush(*wxTRANSPARENT_BRUSH);
		tdc.SetPen(wxPen(Options.GetColour(GridActiveLine)));
		tdc.DrawRectangle(scHor,((Edit->ebrow-scPos+1)*(GridHeight+1))-1,w+scHor,GridHeight+2);
	}

	wxPaintDC dc(this);
	dc.Blit(0,0,firstCol,h,&tdc,0,0);
	dc.Blit(firstCol,0,w+scHor,h,&tdc,scHor+firstCol,0);
}

void SubsGrid::AdjustWidths(int cell)
{

	wxClientDC dc(this);
	dc.SetFont(font);

	int law=0,startMax=0,endMax=0,stw=0,edw=0,syw=0,acw=0,efw=0,fw=0,fh=0;
	bool shml=false,shmr=false,shmv=false;


	int maxx=GetCount();

	dc.GetTextExtent(wxString::Format("%i",GetCount()), &fw, &fh, NULL, NULL, &font);
	GridWidth[0]=fw+10;
	Dialogue *ndial;
	for(int i=0;i<maxx;i++){
		ndial=GetDialCor(i);
		if(START & cell){
			if(ndial->Start.mstime > startMax){startMax = ndial->Start.mstime;}
		}
		if((END & cell) && form!=TMP){
			if(ndial->End.mstime > endMax){endMax = ndial->End.mstime;}
		}


		if(form<SRT){
			if((LAYER & cell) && ndial->Layer!=0){
				dc.GetTextExtent(wxString::Format("%i",ndial->Layer), &fw, &fh, NULL, NULL, &font);
				if(fw+10>law){law=fw+10;}}
			if(STYLE & cell){	
				dc.GetTextExtent(ndial->Style, &fw, &fh, NULL, NULL, &font);
				if(fw+10>syw){syw=fw+10;}}
			if((ACTOR & cell) && ndial->Actor!=""){
				dc.GetTextExtent(ndial->Actor, &fw, &fh, NULL, NULL, &font);
				if(fw+10>acw){acw=fw+10;}}
			if((EFFECT & cell) && ndial->Effect!=""){
				dc.GetTextExtent(ndial->Effect, &fw, &fh, NULL, NULL, &font);
				if(fw+10>efw){efw=fw+10;}}
			if((MARGINL & cell) && ndial->MarginL!=0){shml=true;}
			if((MARGINR & cell) && ndial->MarginR!=0){shmr=true;}
			if((MARGINV & cell) && ndial->MarginV!=0){shmv=true;}
		}
	}

	if(START & cell){
		STime start(startMax);
		if(showFrames){
			VideoFfmpeg *VFF = ((TabPanel*)GetParent())->Video->VFF;
			start.orgframe = VFF->GetFramefromMS(start.mstime);
		}
		dc.GetTextExtent(start.raw(showFrames? FRAME : form), &fw, &fh, NULL, NULL, &font);
		stw=fw+10;
	}
	if(END & cell){
		STime end(endMax);
		if(showFrames){
			VideoFfmpeg *VFF = ((TabPanel*)GetParent())->Video->VFF;
			end.orgframe = VFF->GetFramefromMS(end.mstime);
		}
		dc.GetTextExtent(end.raw(showFrames? FRAME : form), &fw, &fh, NULL, NULL, &font);
		edw=fw+10;
	}

	if((form<SRT)? (LAYER & cell) : (START & cell)){
		wxString frst=(form<SRT)?_("W."):_("Start");
		dc.GetTextExtent(frst, &fw, &fh, NULL, NULL, &font);
		GridWidth[1] = (form<SRT)?law : stw;
		if(fw+10>GridWidth[1]&&GridWidth[1]!=0){GridWidth[1]=fw+10;}
	}

	if((form<SRT)? (START & cell) : (END & cell)){
		wxString scnd=(form<SRT)?_("Start"):_("Koniec");
		dc.GetTextExtent(scnd, &fw, &fh, NULL, NULL, &font);
		GridWidth[2] = (form<SRT)?stw : edw;
		if(fw+10>GridWidth[2]){GridWidth[2]=fw+10;};
	}
	if(form<SRT){
		if(END & cell){
			dc.GetTextExtent(_("Koniec"), &fw, &fh, NULL, NULL, &font);
			GridWidth[3] = edw;
			if(fw+10>GridWidth[3]){GridWidth[3]=fw+10;};
		}

		if(STYLE & cell){
			dc.GetTextExtent(_("Styl"), &fw, &fh, NULL, NULL, &font);
			GridWidth[4] = syw;
			if(fw+10>GridWidth[4]){GridWidth[4]=fw+10;}
		}

		if(ACTOR & cell){
			dc.GetTextExtent(_("Aktor"), &fw, &fh, NULL, NULL, &font);
			if(fw+10>acw&&acw!=0){acw=fw+10;};
			GridWidth[5] = (acw==0)?0:acw;
		}

		if(224 & cell){
			dc.GetTextExtent(_("M.Pi."), &fw, &fh, NULL, NULL, &font);
			if(MARGINL & cell){GridWidth[6]=(!shml)?0:fw+10;}
			if(MARGINR & cell){GridWidth[7]=(!shmr)?0:fw+10;}
			if(MARGINV & cell){GridWidth[8]=(!shmv)?0:fw+10;}
		}

		if(EFFECT & cell){
			dc.GetTextExtent(_("Efekt"), &fw, &fh, NULL, NULL, &font);
			if(fw+10>efw&&efw!=0){efw=fw+10;};
			GridWidth[9] = (efw==0)?0:efw;
		}
	}

	if(CNZ & cell){
		dc.GetTextExtent(_("ZNS"), &fw, &fh, NULL, NULL, &font);
		GridWidth[(form<SRT)?10 : 3]=fw+5;
	}

	if(form==TMP){GridWidth[2]=0;GridWidth[3]=0;GridWidth[10]=0;}
	if(form>ASS){GridWidth[4]=0;GridWidth[5]=0;GridWidth[6]=0;GridWidth[7]=0;GridWidth[8]=0;GridWidth[9]=0;}
	if((form<SRT)? (LAYER & visible) : (START & visible)){GridWidth[1]=0;}
	if((form<SRT)? (START & visible) : (END & visible)){GridWidth[2]=0;}
	if((form<SRT)? (END & visible) : (CNZ & visible)){GridWidth[3]=0;}
	if(STYLE & visible){GridWidth[4]=0;}
	if(ACTOR & visible){GridWidth[5]=0;}
	if(MARGINL & visible){GridWidth[6]=0;}
	if(MARGINR & visible){GridWidth[7]=0;}
	if(MARGINV & visible){GridWidth[8]=0;}
	if(EFFECT & visible){GridWidth[9]=0;}
	if(CNZ & visible){GridWidth[10]=0;}
	first=false;

}


void SubsGrid::Clearing()
{
	sel.clear();
	SAFE_DELETE(Comparison);
	SAFE_DELETE(file);
	SpellErrors.clear();
	Modified=false;
	first=true;
	scPos=0;
	lastRow=0;
	scHor=0;
}
void SubsGrid::AddLine(Dialogue *line)
{
	if(line->NonDial){delete line; return;}
	file->subs->ddials.push_back(line);
	file->subs->dials.push_back(line);
}
void SubsGrid::RepaintWindow(int cell)
{
	AdjustWidths(cell);
	Refresh(false);
}
void SubsGrid::ChangeLine(unsigned char editionType, Dialogue *line1, int wline, long cells, bool selline, bool dummy)
{
	lastRow=wline;
	wxArrayInt sels=GetSels();
	if(sels.size()<2){
		ChangeCell(cells,wline,line1);
	}else{
		for(size_t i=0;i<sels.size();i++){
			ChangeCell(cells,sels[i],line1);
		}
		if(selline){wline=sels[sels.size()-1];}
	}
	if(wline>=GetCount()-1 && selline){
		Dialogue *tmp=new Dialogue(); 
		tmp->State=1;
		int eend=line1->End.mstime; 
		tmp->Start.NewTime(eend); 
		tmp->End.NewTime(eend+5000);
		tmp->Style=line1->Style;
		if(form!=ASS){tmp->Conv(form);}
		AddLine(tmp);
	}
	AdjustWidths(cells);

	if(selline){

		lastRow=wline+1;
		sel.clear();
		sel[lastRow]=true;
		int h,w;
		GetClientSize(&w,&h);
		scPos = MID(0, lastRow-((h/(GridHeight+1))/2), GetCount()-1);

	}
	Refresh(false);
	if(selline){
		Edit->SetLine(lastRow,true,true,false,true);
		/*VideoCtrl *vb = ((TabPanel*)GetParent())->Video;
		if(vb->vToolbar->videoSeekAfter->GetSelection()==1 && vb->vToolbar->videoPlayAfter->GetSelection()<2){
			if(vb->GetState()!=None){
				if(vb->GetState()==Playing){vb->Pause();}
				vb->Seek(Edit->line->Start.mstime);
			}
		}*/
	}
	SetModified(editionType,false,dummy);

}

void SubsGrid::ChangeCell(long wcell, int wline, Dialogue *what)
{
	Dialogue *dial=CopyDial(wline);
	if(wcell & LAYER){
		dial->Layer=what->Layer;}
	if(wcell & START){
		dial->Start=what->Start;}
	if(wcell & END){
		dial->End=what->End;}
	if(wcell & STYLE){
		dial->Style=what->Style;}
	if(wcell & ACTOR){
		dial->Actor=what->Actor;}
	if(wcell & MARGINL){
		dial->MarginL=what->MarginL;}
	if(wcell & MARGINR){
		dial->MarginR=what->MarginR;}
	if(wcell & MARGINV){
		dial->MarginV=what->MarginV;}
	if(wcell & EFFECT){
		dial->Effect=what->Effect;}
	if(wcell & TXT){
		dial->Text=what->Text;}
	if(wcell & COMMENT){
		dial->IsComment=what->IsComment;}
	if(wcell & TXTTL){
		dial->TextTl=what->TextTl;
	}
}

Dialogue *SubsGrid::GetDialCor(int rw)
{
	Dialogue *dial=file->subs->dials[rw];
	if(first){
		if(dial->Form!=form){dial->Conv(form);} 
		if(dial->Start.mstime > dial->End.mstime){
			dial->End.mstime=dial->Start.mstime;
		}
	}
	return dial;
}

void SubsGrid::OnScroll(wxScrollWinEvent& event)
{
	int newPos=0;
	if(event.GetEventType()==wxEVT_SCROLLWIN_LINEUP)
	{
		newPos=scPos-1;
		if(newPos<0){newPos=0;return;}
	}
	else if(event.GetEventType()==wxEVT_SCROLLWIN_LINEDOWN)
	{
		newPos=scPos+1;
		if(newPos>=GetCount()){newPos=GetCount()-1;return;}
	}
	else if(event.GetEventType()==wxEVT_SCROLLWIN_PAGEUP)
	{
		wxSize size=GetClientSize();
		newPos=scPos;
		newPos-=(size.y/GridHeight - 1);
		newPos=MAX(0,newPos);
	}
	else if(event.GetEventType()==wxEVT_SCROLLWIN_PAGEDOWN)
	{
		wxSize size=GetClientSize();
		newPos=scPos;
		newPos+=(size.y/GridHeight - 1);
		newPos=MIN(newPos,GetCount()-1);
	}
	else{
		newPos = event.GetPosition();
	}
	//wxLogStatus("scroll %i %i", newPos, scPos);
	if (scPos != newPos) {
		scPos = newPos;
		Refresh(false);
	}
}

void SubsGrid::OnSize(wxSizeEvent& event)
{
	//wxSize size= GetClientSize();
	Refresh(false);
}

void SubsGrid::SelectRow(int row, bool addToSelected, bool select, bool norefresh)
{
	row = MID(0,row,GetCount()-1);
	if(addToSelected){
		if (!select){sel.erase( sel.find(row));}
		else{sel[row]=select;}
		if(norefresh){return;}
		int w = 0;
		int h = 0;
		GetClientSize(&w,&h);
		RefreshRect(wxRect(0,(row+1-scPos)*(GridHeight+1),w,GridHeight+1),false);
		//Refresh(false);

	}
	else{
		sel.clear();
		sel[row]=select;
		if(norefresh){return;}
		Refresh(false);
	}
	//done:
	if(Edit->Visual==CHANGEPOS){
		Kai->GetTab()->Video->SetVisual();
		Kai->GetTab()->Video->Render();
	}
}

void SubsGrid::ScrollTo(int y, bool center){
	int w,h;
	GetClientSize(&w,&h);
	if(center){y-=(h/(GridHeight+1))/2;}
	int nextY = MID(0,y,GetCount()+2 - h/(GridHeight+1));

	if (scPos != nextY) {
		scPos = nextY;
		Refresh(false);
	}
}

void SubsGrid::SetVideoLineTime(wxMouseEvent &evt)
{
	TabPanel *tab=(TabPanel*)GetParent();
	if(tab->Video->GetState()!=None){
		if(tab->Video->GetState()!=Paused){
			if(tab->Video->GetState()==Stopped){tab->Video->Play();}
			tab->Video->Pause();
		}
		short wh=(form<SRT)?2:1;
		int whh=2;
		for(int i = 0;i<=wh;i++){whh+=GridWidth[i];}
		whh-=scHor;
		bool isstart;
		int vczas;
		bool getEndTime = evt.GetX()>=whh && evt.GetX()<whh+GridWidth[wh+1] && form!=TMP;
		if(getEndTime){ 
			vczas=Edit->line->End.mstime; isstart=false;}
		else{
			vczas=Edit->line->Start.mstime; isstart=true;
		}
		if(evt.LeftDClick() && evt.ControlDown()){vczas-=1000;}
		tab->Video->Seek(MAX(0,vczas),isstart,true,false);
		if(Edit->ABox){Edit->ABox->audioDisplay->Update(getEndTime);}
	}
}

void SubsGrid::OnMouseEvent(wxMouseEvent &event) {

	int w,h;
	GetClientSize (&w, &h);



	bool shift = event.ShiftDown();
	bool alt = event.AltDown();
	bool ctrl = event.CmdDown();

	bool click = event.LeftDown();
	bool left_up = event.LeftUp();
	bool dclick = event.LeftDClick();
	bool middle = event.MiddleDown();
	bool right = event.RightDown();
	int curY=(event.GetY());
	int curX=(event.GetX());
	

	if(ismenushown){ScreenToClient(&curX,&curY);}
	int row = curY / (GridHeight+1)+scPos-1;

	if (left_up && !holding) {
		return;
	}

	// Get focus
	if (event.ButtonDown()) {
		SetFocus();}

	// Popup
	if(click && curX<=GridWidth[0] ){
		TabPanel *tab=(TabPanel*)GetParent();
		if(tab->Video->GetState()!=None && !(row < scPos || row >= GetCount())){
			if(tab->Video->GetState()!=Paused){
				if(tab->Video->GetState()==Stopped){tab->Video->Play();}
				tab->Video->Pause();
			}
			int vtime=0;
			bool isstart=true;
			if(shift && form!=TMP){ 
				vtime=GetDial(row)->End.mstime; isstart=false;}
			else{
				vtime=GetDial(row)->Start.mstime; isstart=true;
			}
			if(ctrl){vtime-=1000;}
			tab->Video->Seek(MAX(0,vtime),isstart,true,false);
			if(Edit->ABox){Edit->ABox->audioDisplay->Update(shift && form!=TMP);}
		}
		return;
	}
	if (right && !ctrl) {
		if(curX<=GridWidth[0]){
			markedLine=row;
			Refresh(false);

		}else{
			ContextMenu(event.GetPosition());
		}

		return;
	}

	// Mouse wheel
	if (event.GetWheelRotation() != 0) {
		int step = 3 * event.GetWheelRotation() / event.GetWheelDelta();
		ScrollTo(scPos - step);
		return;
	}



	if (left_up && holding) {
		holding = false;
		if(event.AltDown() && lastsel!=-1 && file->IsNotSaved()){SetModified(GRID_SWAP_LINES);}
		ReleaseMouse();
		if(oldX!=-1){return;}
	}


	// Click type
	if (click) {
		holding = true;
		if (!shift) lastRow = row;
		lastsel=row;
		oldX=(curY<GridHeight)?curX : -1;
		CaptureMouse();
	}
	if(holding && oldX!=-1){
		int diff=(oldX-curX);
		if((scHor==0&&diff<0)||diff==0||(scHor>1500&&diff>0)){return;}
		scHor=scHor+diff;
		oldX=curX;
		if (scHor<0){scHor=0;}
		Refresh(false);
		return;
	}
	TabPanel *pan=(TabPanel*)GetParent();
	VideoCtrl *video=pan->Video;
	bool changeActive = Options.GetBool(GridChangeActiveOnSelection);
	int mvtal= video->vToolbar->videoSeekAfter->GetSelection();//
	int pas=video->vToolbar->videoPlayAfter->GetSelection();
	if (!(row < scPos || row >= GetCount())) {

		if(holding && alt && lastsel!=row)
		{
			if (lastsel != -1) {
				file->edited=true;
				MoveRows(row-lastsel);
			}
			lastsel=row;
			//return;
		}


		// Toggle selected
		if (left_up && ctrl && !shift && !alt ) {
			if(Edit->ebrow != lastActiveLine || Edit->ebrow != row){
				SelectRow(row,true,!(sel.find(row)!=sel.end()));
				return;
			}
			
		}


		// Normal click
		if (!shift && !alt) {


			//jakbym chciał znów dać zmianę edytowanej linii z ctrl to muszę dorobić mu refresh
			if (click && (changeActive || !ctrl) || (dclick && ctrl)) {/*(click && !ctrl)*/ 
				lastActiveLine = Edit->ebrow;
				Edit->SetLine(row,true,true,true,!ctrl);
				if (transl){ Edit->SetActiveLineToDoubtful(); }
				if(changeActive){Refresh(false);}
				if(!ctrl || dclick){
					SelectRow(row);
					extendRow = -1;
				}
			}

			//1-kliknięcie lewym
			//2-kliknięcie lewym i edycja na pauzie
			//3-kliknięcie lewym i edycja na pauzie i odtwarzaniu

			if (dclick||(click && lastActiveLine != row && mvtal < 4 && mvtal > 0 ) && pas < 2){
				SetVideoLineTime(event);
			}

			if (click || dclick || left_up)
				return;
		}

		if (middle){
			if(video->GetState()!=None){//
				video->PlayLine(GetDial(row)->Start.mstime, video->GetPlayEndTime(GetDial(row)->End.mstime) /*- video->avtpf*/);
			}

		}
	}

	// Scroll to keep visible
	if (holding) {
		// Find direction
		int scdelta=(alt)? 1 : 3;
		int minVis = scPos + 1;
		int maxVis = scPos+h/(GridHeight+1) - 2;
		int delta = 0;
		if (row < minVis && row!=0) delta = -scdelta;
		if (row > maxVis) delta = scdelta;

		if (delta) {
			ScrollTo(scPos + delta);//row - (h / (GridHeight+1)) row

			// End the hold if this was a mousedown to avoid accidental
			// selection of extra lines
			if (click) {// && row!=GetCount()-1
				holding = false;
				left_up = true;
				ReleaseMouse();
			}
		}
	}

	// Block select
	if ((left_up && shift && !alt)|| (holding && !ctrl && !alt && !shift && lastsel!=row)) {
		if (lastRow != -1) {
			// Keyboard selection continues from where the mouse was last used
			extendRow = lastRow;

			// Set boundaries
			row = MID(0,row, GetCount()-1);
			int i1 = row;
			int i2 = lastRow;
			if (i1 > i2) {
				int aux = i1;
				i1 = i2;
				i2 = aux;
			}

			// Toggle each
			bool notFirst = false;
			for (int i=i1;i<=i2;i++) {
				SelectRow(i, notFirst || ctrl,true,true);
				notFirst = true;
			}
			if(changeActive){
				lastActiveLine = Edit->ebrow;
				Edit->SetLine(row,true,true,false);
				if (transl){ Edit->SetActiveLineToDoubtful(); }
				//if(mvtal < 4 && mvtal > 0){
					//SetVideoLineTime(event);
				//}
			}
			lastsel=row;
			Refresh(false);
			if(Edit->Visual==CHANGEPOS/* || Edit->Visual==MOVEALL*/){
				video->SetVisual();
				video->Render();
			}
		}
	}


}

void SubsGrid::Convert(char type)
{
	if(GetSInfo("TLMode")=="Yes"){return;}
	if(Options.GetBool(ConvertShowSettings)){
		OptionsDialog od(Kai,Kai);
		od.OptionsTree->ChangeSelection(2);
		od.okok->SetFocus();
		if(od.ShowModal()==wxID_CANCEL){return;}
	}
	if(Options.GetBool(ConvertFPSFromVideo) && Kai->GetTab()->VideoPath!=""){
		Options.SetString(ConvertFPS, Kai->GetStatusText(4).BeforeFirst(' '));
	}
	if(Options.GetFloat(ConvertFPS)<1){KaiMessageBox(_("Nieprawidłowy FPS. Popraw opcje i spróbuj ponownie."));return;}

	bool newendtimes=Options.GetBool(ConvertNewEndTimes);
	wxString stname=Options.GetString(ConvertStyle);
	int endt=Options.GetInt(ConvertTimePerLetter);
	wxString prefix=Options.GetString(ConvertASSTagsOnLineStart);
	//KaiMessageBox("pętla");
	int i=0;
	while(i<GetCount())
	{
		//Dialogue *dial=GetDial(i);
		if((type>ASS) && (form<SRT) && GetDial(i)->IsComment){
			while(GetDial(i)->IsComment){
				DeleteRow(i);
			}
		}
		Dialogue *dialc=CopyDial(i);
		dialc->Conv(type,prefix);
		if((newendtimes && type!=TMP)||form==TMP)
		{
			if(i>0){
				if(GetDial(i-1)->End.mstime > dialc->Start.mstime){
					GetDial(i-1)->End = dialc->Start;
				}
			}

			int newend=(endt * dialc->Text.Len());
			if(newend<1000){newend=1000;}
			newend += dialc->Start.mstime;
			dialc->End.NewTime(newend);
		}

		i++;	
	}

	if(type==ASS){
		LoadDefault(false,true,false);
		wxString resx=Options.GetString(ConvertResolutionWidth);
		wxString resy=Options.GetString(ConvertResolutionHeight);
		if(resx==""){resx="1280";}
		if(resy==""){resx="720";}
		AddSInfo("PlayResX",resx, false);
		AddSInfo("PlayResY",resy, false);
		AddSInfo("YCbCr Matrix","TV.601",false);
		wxString catalog=Options.GetString(ConvertStyleCatalog);

		if(Options.dirs.Index(catalog)!=-1){Options.LoadStyles(catalog);}
		int stind=Options.FindStyle(stname);

		if(stind<0){Styles *newstyl=new Styles(); newstyl->Name=stname;AddStyle(newstyl);}
		else{AddStyle(Options.GetStyle(stind)->Copy());}
		Edit->RefreshStyle();
		Kai->SetSubsResolution();
	}
	if(form==ASS){
		std::sort(file->subs->dials.begin(),file->subs->dials.end(),[](Dialogue *i, Dialogue *j){
			if(i->Start.mstime!=j->Start.mstime){
				return (i->Start.mstime<j->Start.mstime);
			}
			if(i->End.mstime!=j->End.mstime){
				return (i->End.mstime<j->End.mstime);
			}
			//if(i->Style!=j->Style){
			//return (i->Style.CmpNoCase(j->Style)<0);
			//}
			return (i->Text.CmpNoCase(j->Text)<0);
		});
		Dialogue *lastDialogue = GetDial(0);
		int i = 1; 
		while(i < GetCount()){
			Dialogue *actualDialogue = GetDial(i);
			if(lastDialogue->Start == actualDialogue->Start && 
				lastDialogue->End == actualDialogue->End && 
				lastDialogue->Text == actualDialogue->Text){
					DeleteRow(i-1);
					lastDialogue = actualDialogue;
					continue;
			}else if(actualDialogue->Text==""){
				DeleteRow(i);
				continue;
			}
			lastDialogue = actualDialogue;
			i++;
		}
		Kai->SetStatusText("",5);
		
	}else if(type == ASS){
		Kai->SetSubsResolution();
	}

	form=type;
	Edit->SetLine((Edit->ebrow < GetCount())? Edit->ebrow : 0);
	SetModified(GRID_CONVERT);
	RepaintWindow();
	
	if(Edit->Visual > 0){
		TabPanel *tab = Kai->GetTab();
		tab->Video->SetVisual(true);
	}
}
/*
DWORD SubsGrid::saveproc(void* param)
{
SubsGrid * grid = (SubsGrid*)param;
wxString txt=grid->GetSInfo("TLMode Style");
wxString kkk=grid->GetSInfo("TLMode");
//wxString mode = (wxFile::Exists(grid->fn))? 
//OpenWrite ow(grid->fn,false);
//FILE *file = _wfopen(grid->fn.fn_str(),L"a+b");
//wxFFile file;
//file.Open(grid->fn, "a+");
//wxString tmppath="\\?\\"+grid->fn;

HANDLE ffile=CreateFile(grid->fn.fn_str(), GENERIC_WRITE, FILE_SHARE_WRITE,NULL, OPEN_EXISTING, 0, NULL);

//wxMutex mutex1;
DWORD savesize=0;
wxMutex mutex2;
while(1)
{
if(grid->acline>=grid->GetCount()){break;}
Dialogue *dial=grid->GetDial(grid->acline++);
//grid->acline++;

wxString wynik;
if(kkk!=""){
if(kkk!="Translated" && dial->TextTl!=""){
wynik<<dial->GetRaw(false,txt)<<dial->GetRaw(true);
}
else{
wynik<<dial->GetRaw(dial->TextTl!="");
}
}else{
if(grid->form==SRT){wynik<<grid->acline+1<<"\r\n";}
wynik<<dial->GetRaw();

}
if(dial->State==1&&grid->cstate){dial->State=2;}
wxScopedCharBuffer buffer= wynik.mb_str(wxConvUTF8);//mb_str(wxConvUTF8)//wxScopedCharBuffer 
int size = strlen(buffer);
grid->mutex.Lock();
SetFilePointer(ffile,0,0,FILE_END);
WriteFile(ffile, buffer, size, &savesize, 0);
grid->mutex.Unlock();
}
//ow.CloseFile();
//file.Close();
CloseHandle(ffile);
return 0;
}
*/
void SubsGrid::SaveFile(const wxString &filename, bool cstat, bool loadFromEditbox)
{
	int saveAfterCharacterCount = Options.GetInt(GridSaveAfterCharacterCount);
	bool dummyEditboxChanges = (loadFromEditbox && !saveAfterCharacterCount);
	if (dummyEditboxChanges || saveAfterCharacterCount > 1){
		bool oldOnVideo = Edit->OnVideo;
		// no i tu mamy do poprawki dummy subs;
		Edit->Send(EDITBOX_LINE_EDITION, false, dummyEditboxChanges, true);
		Edit->OnVideo = oldOnVideo;
	}
	wxString txt;
	wxString tlmode = GetSInfo("TLMode");
	bool translated = tlmode == "Translated";
	bool tlmodeOn = tlmode != "";

	OpenWrite ow(filename,true);

	if (form<SRT){
		if(cstat){
			AddSInfo("Last Style Storage",Options.acdir, false);
			AddSInfo("Active Line", std::to_string(Edit->ebrow), false);
		}

		txt<<"[Script Info]\r\n;Plik utworzony przez "<<Options.progname<<"\r\n"<<GetSInfos(translated);
		txt<<"\r\n[V4+ Styles]\r\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding \r\n";
		txt<<GetStyles(translated);
		txt<<" \r\n[Events]\r\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\r\n";
	}
	ow.PartFileWrite(txt);

	txt=GetSInfo("TLMode Style");
	wxString raw;
	
	for(int i=0;i<GetCount();i++)
	{
		//a tu trzeba w przypadku ebrow pobrać editbox line
		Dialogue *dial = (dummyEditboxChanges && i == Edit->ebrow)? Edit->line : GetDial(i);
		
		if(tlmodeOn){
			bool hasTextTl = dial->TextTl!="";
			if(!translated && (hasTextTl || dial->State & 4)){
				dial->GetRaw(&raw, false,txt);
				dial->GetRaw(&raw, true);
			}else{
				dial->GetRaw(&raw, hasTextTl);
			}
		}else{
			
			if(form==SRT){
				raw<<i+1<<"\r\n";
			}
			dial->GetRaw(&raw);
		}
		//if(i % 30 == 29){
		ow.PartFileWrite(raw);
		raw.Empty();
		//}
		if(dial->State & 1 && cstat){dial->State++;}

	}
	
	ow.CloseFile();
	if(cstat){Refresh(false);}
}

void SubsGrid::HideOver()
{
	hideover=!hideover;
	Options.SetBool(GridHideTags,hideover);
	SpellErrors.clear();
	Refresh(false);
}

void SubsGrid::AddStyle(Styles *nstyl)
{
	file->subs->dstyles.push_back(nstyl);
	file->subs->styles.push_back(nstyl);
}

void SubsGrid::ChangeStyle(Styles *nstyl, int i)
{
	file->subs->dstyles.push_back(nstyl);
	file->subs->styles[i]=nstyl;
}

int SubsGrid::StylesSize()
{
	return file->subs->styles.size();
}

Styles *SubsGrid::GetStyle(int i,wxString name)
{
	if(name!=""){
		for(unsigned int j=0; j < file->subs->styles.size();j++)
		{
			if(name==file->subs->styles[j]->Name){return file->subs->styles[j];}
		}
	}
	return file->subs->styles[i];
}

std::vector<Styles*> *SubsGrid::GetStyleTable()
{
	return &file->subs->styles;
}

//multiplication musi być ustawione na zero, wtedy zwróci ilość multiplikacji
int SubsGrid::FindStyle(wxString name,int *multip)
{
	int isfound=-1;
	for(unsigned int j=0;j < file->subs->styles.size();j++)
	{
		if(name==file->subs->styles[j]->Name){
			isfound=j;
			if(multip){*multip++;
			}else{break;}
		}
	}
	return isfound;
}

wxString SubsGrid::GetStyles(bool tld)
{   
	wxString allst;
	wxString tmpst;
	if(tld){tmpst=GetSInfo("TLMode Style");}
	for(size_t i=0;i<file->subs->styles.size();i++)
	{
		if(!(tld&&file->subs->styles[i]->Name==tmpst)){
			allst<<file->subs->styles[i]->styletext();}
	}
	return allst;
}

void SubsGrid::DelStyle(int i)
{
	file->edited=true;
	file->subs->styles.erase(file->subs->styles.begin()+i);
}

int SubsGrid::GetCount()
{
	return file->subs->dials.size();
}

int SubsGrid::FirstSel()
{
	if(!sel.empty()){
		return sel.begin()->first;
	}
	return -1;
}

class compare { // simple comparison function
public:
	bool operator()(Dialogue *i,Dialogue *j) {

		if(i->Start.mstime!=j->Start.mstime){
			return (i->Start.mstime<j->Start.mstime);
		}
		return i->End.mstime<j->End.mstime;
	} // returns x>y
};

void SubsGrid::ChangeTimes(bool byFrame)
{
	VideoCtrl *vb=((TabPanel*)GetParent())->Video;
	if(byFrame && !vb->VFF){wxLogMessage(_("Wideo nie zostało wczytane przez FFMS2"));return;}
	//1 forward / backward, 2 Start Time For V/A Timing, 4 Move to video time, 8 Move to audio time;
	int moveTimeOptions = Options.GetInt(MoveTimesOptions);
	
	//Time to move
	int time = (!byFrame)? Options.GetInt(MoveTimesTime) : 0;
	int frame = (byFrame)? Options.GetInt(MoveTimesFrames) : 0;
	int whichLines = MAX(0,Options.GetInt(MoveTimesWhichLines));
	int whichTimes = MAX(0,Options.GetInt(MoveTimesWhichTimes));
	int correctEndTimes  = Options.GetInt(MoveTimesCorrectEndTimes);
	//1 Lead In, 2 Lead Out, 4 Make times continous, 8 Snap to keyframe;
	int PostprocessorOptions  = Options.GetInt(PostprocessorEnabling);
	int li=0, lo=0, ts=0, te=0, kbs=0, kas=0, kbe=0, kae=0;
	if(PostprocessorOptions){
		if(form==TMP || PostprocessorOptions<16){PostprocessorOptions=0;}
		else if(PostprocessorOptions & 8 && !vb->VFF){PostprocessorOptions^=8;}
		li  = Options.GetInt(PostprocessorLeadIn);
		lo  = Options.GetInt(PostprocessorLeadOut);
		ts  = Options.GetInt(PostprocessorThresholdStart);
		te  = Options.GetInt(PostprocessorThresholdEnd);
		kbs = Options.GetInt(PostprocessorKeyframeBeforeStart);
		kas = Options.GetInt(PostprocessorKeyframeAfterStart);
		kbe = Options.GetInt(PostprocessorKeyframeBeforeEnd);
		kae = Options.GetInt(PostprocessorKeyframeAfterEnd);
	}
	wxString style=Options.GetString(MoveTimesStyles);
	bool changeTagTimes = (moveTimeOptions & 32) > 0;

	if(!(moveTimeOptions & 1)){
		time = (-time);
		frame = (-frame);
	}
	// video / audio move start or end
	int VAS = moveTimeOptions & 2;


	std::map<Dialogue *,int,compare> tmpmap;


	if(whichTimes!=0){
		int answer=KaiMessageBox(wxString::Format(_("Czy naprawdę chcesz przesuwać tylko czasy %s?"), 
			(whichTimes==1)? _("początkowe") : _("końcowe")),_("Potwierdzenie"),wxYES_NO);
		if(answer==wxNO){return;}
	}

	if(form==TMP){whichTimes=1;}

	bool fromstyl=false;

	int fs=FirstSel();
	if (fs==-1 && whichLines!=0 && whichLines!=4){
		KaiMessageBox(_("Nie zaznaczono linii do przesunięcia"),_("Uwaga"));return;
	}

	int difftime=(VAS)? file->subs->dials[markedLine]->Start.mstime : file->subs->dials[markedLine]->End.mstime;
	//Start time - halfframe / end time + halfframe
	if((moveTimeOptions & 4) && vb->GetState()!=None){
		if(byFrame){
			frame += vb->GetCurrentFrame() - vb->VFF->GetFramefromMS(difftime);
		}else{
			int addedTimes= vb->GetFrameTime(VAS != 0) - difftime;
			if(addedTimes<0){addedTimes-=10;}
			time += ZEROIT(addedTimes);
		}
		
	}
	else if((moveTimeOptions & 8) && Edit->ABox->audioDisplay->hasMark){
		if(byFrame){
			frame += vb->VFF->GetFramefromMS(Edit->ABox->audioDisplay->curMarkMS - difftime);
		}else{
			int addedTimes= Edit->ABox->audioDisplay->curMarkMS - difftime;
			if(addedTimes<0){addedTimes-=10;}
			time += ZEROIT(addedTimes);
		}
	}


	wxArrayString stcomp;
	if(whichLines == 4){
		int g=0;
		wxStringTokenizer styles(style,";");
		while(styles.HasMoreTokens()){
			wxString styl=styles.GetNextToken();
			styl.Trim(false);
			styl.Trim(true);
			stcomp.Add(styl);

			g++;
		}
	}

	int firsttime=GetDial(fs)->Start.mstime;
	//int endDiff = 0;
	Dialogue *dialc;

	for (int i=0;i<GetCount();i++)
	{
		if(whichLines==4 && stcomp.GetCount()>0 ){
			fromstyl=false;
			wxString styl=file->subs->dials[i]->Style;
			for(size_t i=0;i<stcomp.GetCount();i++){
				if(styl==stcomp[i]){fromstyl=true;}
			}
		}

		if( whichLines==0
			|| ( whichLines==1 && sel.find(i) != sel.end() ) 
			|| ( whichLines==3 && firsttime <= file->subs->dials[i]->Start.mstime ) 
			|| ( whichLines==2 && i>=fs )
			|| fromstyl)
		{

			dialc=file->CopyDial(i,true,true);
			int startTrimed = 0, endTrimed = 0, duration = 0;
			if(changeTagTimes){
				vb->GetStartEndDelay(dialc->Start.mstime, dialc->End.mstime, &startTrimed, &endTrimed);
			}
			if(time!=0){
				if(whichTimes!=2){dialc->Start.Change(time);}
				if(whichTimes!=1){dialc->End.Change(time);}
				dialc->State = 1 + (dialc->State & 4);
			}else if(frame!=0){
				if(whichTimes==0){
					duration = dialc->End.mstime - dialc->Start.mstime;
				}
				if(whichTimes!=2){
					int startFrame = vb->VFF->GetFramefromMS(dialc->Start.mstime)+frame;
					dialc->Start.NewTime(ZEROIT(vb->GetFrameTimeFromFrame(startFrame)));
				}
				if(whichTimes!=1){
					//endDiff = dialc->End.mstime;
					int endFrame = vb->VFF->GetFramefromMS(dialc->End.mstime)+frame;
					dialc->End.NewTime(ZEROIT(vb->GetFrameTimeFromFrame(endFrame)));
					//endDiff = dialc->End.mstime - endDiff;
				}
				dialc->State=1 + (dialc->State & 4);
			}
			if(changeTagTimes){
				int newStartTrimed=0, newEndTrimed=0;
				vb->GetStartEndDelay(dialc->Start.mstime, dialc->End.mstime, &newStartTrimed, &newEndTrimed);
				if(byFrame){newEndTrimed += ((dialc->End.mstime - dialc->Start.mstime) - duration);}
				dialc->ChangeTimes(newStartTrimed - startTrimed, (newEndTrimed - endTrimed));
			}

			if(correctEndTimes>0 || PostprocessorOptions>16){
				if(correctEndTimes>1){
					int endt=Options.GetInt(ConvertTimePerLetter);
					int newend=(endt*dialc->Text.Len());
					if(newend<1000){newend=1000;}
					newend+=dialc->Start.mstime;
					dialc->End.NewTime(newend);
				}
				if(PostprocessorOptions & 1){dialc->Start.Change(-li);dialc->State=1 + (dialc->State & 4);}
				if(PostprocessorOptions & 2){dialc->End.Change(lo);dialc->State=1 + (dialc->State & 4);}
				if(correctEndTimes>0 || PostprocessorOptions>19){
					tmpmap[dialc]=i;

				}
			}else{
				dialc->ClearParse();
			}

		}// if przesuwana linia

	}//pętla for

	// tu jeszcze należy poprawić uwzględniając linijkę z czasem przed tablicą i czasem po niej
	// a może to w ogóle nie jest potrzebne?
	if(correctEndTimes>0 || PostprocessorOptions>19){
		bool hasend=false;
		int newstarttime=-1;

		for(auto cur=tmpmap.begin(); cur != tmpmap.end(); cur++){
			auto it = cur;
			dialc = cur->first;//file->subs->dials[cur->second];
			it++;
			if(!(it!=tmpmap.end())){it=cur; hasend=true;}
			if(correctEndTimes>0 && dialc->End > it->first->Start && !hasend){
				dialc->End = it->first->Start;
				dialc->State=1 + (dialc->State & 4);
			}
			if(PostprocessorOptions & 4){
				int cdiff= (te+ts);
				int tdiff = it->first->Start.mstime - dialc->End.mstime;
				if(newstarttime != -1){
					dialc->Start.NewTime(newstarttime);
					newstarttime = -1;
					dialc->State=1 + (dialc->State & 4);
				}
				if(tdiff <= cdiff && tdiff > 0){
					int wsp = ((float)tdiff / (float)cdiff)*te;
					int newtime=ZEROIT(wsp);
					dialc->End.Change(newtime);
					newstarttime = dialc->End.mstime;
					dialc->State=1 + (dialc->State & 4); 

				}

			}
			if(PostprocessorOptions & 8){
				int strtrng = dialc->Start.mstime - kbs;
				int strtrng1 = dialc->Start.mstime + kas;
				int endrng = dialc->End.mstime - kbe;
				int endrng1 = dialc->End.mstime + kae;
				int pors = 0;
				int pore = (hasend)? INT_MAX : it->first->Start.mstime + kas;

				if(cur!=tmpmap.begin()){
					it--;
					if(!hasend){it--;}
					pors = it->first->End.mstime - kbe;
				}

				int keyMS=0;
				int strtres=INT_MAX;
				int endres=-1;
				for (unsigned int g=0;g<vb->VFF->KeyFrames.Count();g++) {
					keyMS = vb->VFF->KeyFrames[g];
					if (keyMS > strtrng && keyMS < strtrng1) {
						keyMS = ZEROIT(vb->GetFrameTimeFromTime(keyMS));
						if(strtres>keyMS && keyMS != dialc->Start.mstime){strtres = keyMS;}
					}
					if (keyMS > endrng && keyMS < endrng1) {
						keyMS = ZEROIT(vb->GetFrameTimeFromTime(keyMS));
						if(endres<keyMS && keyMS > dialc->Start.mstime){endres = keyMS;}
					}
				}
				if(strtres!=INT_MAX && strtres >= pors){
					dialc->Start.NewTime(strtres);
					dialc->State=1 + (dialc->State & 4);
				}
				if(endres!=-1 && endres <= pore){
					dialc->End.NewTime(endres);
					dialc->State=1 + (dialc->State & 4);
				}
			}
			dialc->ClearParse();
		}

	}

	SpellErrors.clear();
	int tmpMarked = markedLine;
	SetModified(SHIFT_TIMES, true, false, -1, false);
	markedLine = tmpMarked;
	if(form>TMP){RepaintWindow(START|END);}else{Refresh(false);}
#if _DEBUG
	wxBell();
#endif
}


void SubsGrid::SortIt(short what, bool all)
{

	std::vector<Dialogue*> selected;
	if(all){
		for(int i=0;i<GetCount();i++){file->subs->dials[i]->State=1 + (file->subs->dials[i]->State & 4);}
	}else{
		for(auto cur=sel.begin(); cur!=sel.end(); cur++){
			Dialogue *dial=file->subs->dials[cur->first];
			dial->State=1 + (dial->State & 4);
			selected.push_back(dial);
		}
	}
	std::sort((all)? file->subs->dials.begin() : selected.begin(), (all)? file->subs->dials.end() : selected.end(),
		(what==0)? sortstart : (what==1)? sortend : (what==2)? sortstyle : 
		(what==3)? sortactor : (what==4)? sorteffect : sortlayer);

	if(!all){
		int ii=0;
		for(auto cur=sel.begin(); cur!=sel.end(); cur++){
			file->subs->dials[cur->first]=selected[ii++];
		}
		selected.clear();
	}
	file->edited=true;
	SpellErrors.clear();
	SetModified(GRID_SORT_LINES);
	Refresh(false);
} 

void SubsGrid::OnKeyPress(wxKeyEvent &event) {
	// Get size
	int w,h;
	GetClientSize(&w,&h);

	// Get scan code
	int key = event.GetKeyCode();
	bool ctrl = event.m_controlDown;
	bool alt = event.m_altDown;
	bool shift = event.m_shiftDown;

	// The "menu" key, simulate a right-click
	if (key == WXK_WINDOWS_MENU) {
		wxPoint pos;
		pos.x = w/2;
		pos.y = (Edit->ebrow+1-scPos) * GridHeight + GridHeight/2;
		ContextMenu(pos);
		return;
	}

	// Select all
	if (key == 'A' && ctrl && !alt && !shift) {
		//SelectRow(0,false,true,true);
		for(int i=0;i<GetCount();i++){
			sel[i]=true;
		}
		Refresh(false);
	}

	// Up/down
	int dir = 0;
	if (key == WXK_UP) dir = -1;
	if (key == WXK_DOWN) dir = 1;
	if (key == WXK_PAGEUP) {
		dir = -(h/GridHeight - 1);
	}
	if (key == WXK_PAGEDOWN) {
		dir = h/GridHeight - 1;
	}
	if (key == WXK_HOME) {
		dir = -GetCount();
	}
	if (key == WXK_END) {
		dir = GetCount();
	}
	if (key == WXK_RETURN){
		Edit->TextEdit->SetFocus();}

	// Moving
	if (dir) {
		// Move selection
		if (!ctrl && !shift && !alt) {
			// Move to extent first
			int curLine = Edit->ebrow;
			if (extendRow != -1) {
				curLine = extendRow;
				extendRow = -1;
			}

			int next = MID(0,curLine+dir,GetCount()-1);
			Edit->SetLine(next);
			SelectRow(next);
			int gridh=((h/(GridHeight+1))-1);
			if(dir==1||dir==-1){
				bool above= (next<=scPos);
				bool below= (next>=scPos+gridh);
				if(above||below){ScrollTo(above? next-1 : next-gridh+1);}
			}else{
				ScrollTo(next);}
			lastRow=next;
			//return;
		}


		// Move selected
		else if (alt&&!shift) {
			if((dir==1||dir==-1)&&FirstSel()!=-1){
				MoveRows(dir,true);
				ScrollTo(scPos+dir);
			}
			//return;
		}

		// Shift-selection
		else if (shift && !ctrl && !alt) {
			// Find end
			if (extendRow == -1) extendRow = Edit->ebrow;
			extendRow = lastRow = MID(0,extendRow+dir,GetCount()-1);
			// Set range
			int i1 = Edit->ebrow;
			int i2 = extendRow;
			if (i2 < i1) {
				int aux = i1;
				i1 = i2;
				i2 = aux;
			}

			// Select range
			bool notfirst=false;
			for (int i=i1;i<=i2;i++) {
				SelectRow(i,notfirst);
				notfirst=true;
			}

			int gridh=((h/(GridHeight+1))-1);
			if(extendRow==scPos&&(dir==1||dir==-1)){
				ScrollTo(extendRow-1);}
			else if(extendRow==scPos+gridh&&(dir==1||dir==-1)){
				ScrollTo(extendRow-gridh+1);}
			else if(dir!=1&&dir!=-1){
				ScrollTo(extendRow);}
			//return;
		}
		if (transl){ Edit->SetActiveLineToDoubtful(); }
	}




}

void SubsGrid::DeleteRow(int rw, int len)
{
	int rwlen=rw+len;
	file->edited=true;
	file->subs->dials.erase(file->subs->dials.begin()+rw, file->subs->dials.begin()+rwlen);
	if((int)SpellErrors.size()>rwlen){ SpellErrors.erase(SpellErrors.begin()+rw, SpellErrors.begin()+rwlen);}
	else{SpellErrors.clear();}
}

void SubsGrid::DeleteRows()
{
	Freeze();
	wxArrayInt sels=GetSels(true);
	for(int i= sels.size()-1; i>=0; i--)
	{
		file->subs->dials.erase(file->subs->dials.begin()+sels[i]);
		SpellErrors.erase(SpellErrors.begin()+sels[i]);
	}
	if(GetCount()<1){AddLine(new Dialogue());}
	if(sels.size()>0){file->edited=true;}
	SetModified(GRID_DELETE_LINES);
	Thaw();
	RepaintWindow();
}

void SubsGrid::MoveRows(int step, bool sav)
{
	wxArrayInt sels=GetSels();

	if (sels.GetCount()<1){return;}
	if(step<0){

		for (size_t i=0;i<sels.GetCount();i++)
		{
			int istep=sels[i]+step;
			//if(istep<tmpstep){istep=tmpstep;tmpstep++;}
			if(istep<0){break;}
			sel[istep]=true;
			sel.erase(sel.find(sels[i]));
			if(step!=-1){
				InsertRows(istep,1,GetDial(sels[i]),false);
				DeleteRow(sels[i],1);
			}else{
				SwapRows(sels[i],istep);
			}

		}
	}else
	{
		for (int i=sels.GetCount()-1;i>=0;i--)
		{
			int istep=sels[i]+step;
			//if(istep<0){istep=tmpstep;tmpstep++;}
			if(istep>GetCount()-1) break;
			sel[istep]=true;
			sel.erase(sel.find(sels[i]));
			if(step!=1){
				//break;
				Dialogue *dial=GetDial(sels[i]);
				DeleteRow(sels[i],1);
				InsertRows(istep,1,dial,false);
			}
			else{
				SwapRows(sels[i],istep);
			}
		}
	}
	Edit->SetLine(FirstSel());
	Refresh(false);
}

void SubsGrid::DeleteText()
{
	for (int i=0;i<GetCount();i++)
	{
		if(sel.find(i)!=sel.end()){
			CopyDial(i)->Text="";}
	}
	SetModified(GRID_DELETE_TEXT);
	Refresh(false);
}
void SubsGrid::UpdateUR(bool toolbar)
{
	bool undo=false, _redo=false;
	file->GetURStatus(&undo, &_redo);
	Kai->Menubar->Enable(Undo,undo);
	Kai->Menubar->Enable(Redo,_redo);
	Kai->Menubar->Enable(SaveSubs, true);
	if(toolbar){
		Kai->Toolbar->UpdateId(Undo,undo);
		Kai->Toolbar->UpdateId(Redo,_redo);
		Kai->Toolbar->UpdateId(SaveSubs, true);
	}
}

void SubsGrid::GetUndo(bool redo, int iter)
{
	TabPanel *pan =Kai->GetTab();
	Freeze();
	wxString resolution = GetSInfo("PlayResX") +" x "+ GetSInfo("PlayResY");
	wxString matrix = GetSInfo("YCbCr Matrix");
	wxString tlmode = GetSInfo("TLMode");

	if(iter != -2){if(file->SetHistory(iter)){Thaw();return;}}
	else if(redo){file->Redo();}else{file->Undo();}


	UpdateUR();

	Kai->Label(file->Iter());


	char oldform=form;SetSubsForm();
	if(oldform!=form){
		pan->CTime->Contents();
		pan->Edit->HideControls();
		Kai->UpdateToolbar();
	}

	int erow=Edit->ebrow;
	if(erow>=GetCount()){
		erow=GetCount()-1;
		sel.clear();
		sel[erow]=true;
		lastRow=erow;
	}

	Thaw();

	if(StyleStore::HasStore()){
		StyleStore *SS = StyleStore::Get();
		SS->ASS->SetArray(&file->subs->styles);
		SS->ASS->Refresh(false);
	}
	SpellErrors.clear();

	wxString newtlmode = GetSInfo("TLMode");
	if(newtlmode != tlmode){
		transl = (newtlmode == "Yes");
		showtl = (GetSInfo("TLMode Showtl") == "Yes" || (transl && Options.GetBool(TlModeShowOriginal) != 0));
		Edit->SetTl(transl);
	}

	RepaintWindow();
	int tmpMarked = markedLine;
	Edit->SetLine(erow);
	markedLine = tmpMarked;
	Edit->RefreshStyle();
	for(auto cur = sel.begin(); cur != sel.end(); cur++){
		if(cur->first >= GetCount()){
			sel.erase(cur,sel.end());
			break;
		}
	}
	VideoCtrl *vb=pan->Video;
	if(Edit->Visual < CHANGEPOS){
		
		if(vb->IsShown() || vb->isFullscreen){vb->OpenSubs(GetVisible()/*SaveText()*/);Edit->OnVideo=true;}
		int opt=vb->vToolbar->videoSeekAfter->GetSelection();//Options.GetInt(MoveVideoToActiveLine);
		if(opt>1){
			if(vb->GetState()==Paused || (vb->GetState()==Playing && (opt==3 || opt==5))){
				vb->Seek(Edit->line->Start.mstime);}
		}else{
			if(vb->GetState()==Paused){vb->Render();}
		}
	}else if(Edit->Visual==CHANGEPOS){
		vb->SetVisual(false, true);
	}
	wxString newResolution = GetSInfo("PlayResX") +" x "+ GetSInfo("PlayResY");
	if(resolution != newResolution){Kai->SetSubsResolution();}
	wxString newmatrix = GetSInfo("YCbCr Matrix");
	if(matrix != newmatrix){
		vb->SetColorSpace(newmatrix);
	}
	

	if(makebkp){
		timer.Start(20000,true);
		//CreateTimerQueueTimer(&qtimer,0,WAITORTIMERCALLBACK(OnBcktimer),this,20000,0,WT_EXECUTEONLYONCE);
		makebkp=false;
	}
}
>>>>>>> master

#include <wx/intl.h>
#include <wx/string.h>
#include "Utils.h"
#include <wx/clipbrd.h>
#include "KainoteMain.h"
#include "Hotkeys.h"
#include "OpennWrite.h"
#include "TLDialog.h"
#include "MKVWrap.h"
#include "Stylelistbox.h"
#include "Menu.h"
#include <wx/regex.h>
#include "KaiMessageBox.h"

SubsGrid::SubsGrid(wxWindow* parent, kainoteFrame* kfparent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style)
	:SubsGridBase(parent, id, pos, size, style)
{
	Kai=kfparent;
	Bind(wxEVT_COMMAND_MENU_SELECTED,[=](wxCommandEvent &evt){
		int id = ((MenuItem*)evt.GetClientData())->id;
		if(id>5000 && id<5555){
			int id5000=(id-5000);
			if(visibleColumns & id5000){visibleColumns ^= id5000;}
			else{visibleColumns |= id5000;}
			SpellErrors.clear();
			Options.SetInt(GridHideCollums, visibleColumns);
			RefreshColumns();
		}
	},ID_CHECK_EVENT);
}

SubsGrid::~SubsGrid()
{
}

void SubsGrid::ContextMenu(const wxPoint &pos, bool dummy)
{
	VideoCtrl *VB=((TabPanel*)GetParent())->Video;
	VB->blockpaint=true;
	selarr = GetSels();
	int sels=selarr.GetCount();
	Menu *menu=new Menu(GRID_HOTKEY);
	Menu *hidemenu=new Menu(GRID_HOTKEY);
	MenuItem *item;
	item = hidemenu->SetAccMenu(5000+LAYER,_("Ukryj warstwę"),_("Ukryj warstwę"),true, ITEM_CHECK);
	item->Enable(subsFormat<SRT);
	item->Check((visibleColumns & LAYER)!=0);
	hidemenu->SetAccMenu(5000+START,_("Ukryj czas początkowy"),_("Ukryj czas początkowy"),true, ITEM_CHECK)->Check((visibleColumns & START)!=0);
	item = hidemenu->SetAccMenu(5000+END,_("Ukryj czas końcowy"),_("Ukryj czas końcowy"),true, ITEM_CHECK);
	item->Enable(subsFormat!=TMP);
	item->Check((visibleColumns & END)!=0);
	item = hidemenu->SetAccMenu(5000+ACTOR,_("Ukryj aktora"),_("Ukryj aktora"),true, ITEM_CHECK);
	item->Enable(subsFormat<SRT);
	item->Check((visibleColumns & ACTOR)!=0);
	item = hidemenu->SetAccMenu(5000+STYLE,_("Ukryj styl"),_("Ukryj styl"),true, ITEM_CHECK);
	item->Enable(subsFormat<SRT);
	item->Check((visibleColumns & STYLE)!=0);
	item = hidemenu->SetAccMenu(5000+MARGINL,_("Ukryj lewy margines"),_("Ukryj lewy margines"),true, ITEM_CHECK);
	item->Enable(subsFormat<SRT);
	item->Check((visibleColumns & MARGINL)!=0);
	item = hidemenu->SetAccMenu(5000+MARGINR,_("Ukryj prawy margines"),_("Ukryj prawy margines"),true, ITEM_CHECK);
	item->Enable(subsFormat<SRT);
	item->Check((visibleColumns & MARGINR)!=0);
	item = hidemenu->SetAccMenu(5000+MARGINV,_("Ukryj pionowy margines"),_("Ukryj pionowy margines"),true, ITEM_CHECK);
	item->Enable(subsFormat<SRT);
	item->Check((visibleColumns & MARGINV)!=0);
	item = hidemenu->SetAccMenu(5000+EFFECT,_("Ukryj efekt"),_("Ukryj efekt"),true, ITEM_CHECK);
	item->Enable(subsFormat<SRT);
	item->Check((visibleColumns & EFFECT)!=0);
	hidemenu->SetAccMenu(5000+CNZ,_("Ukryj znaki na sekundę"),_("Ukryj znaki na sekundę"),true, ITEM_CHECK)->Check((visibleColumns & CNZ)!=0);

	bool isen;
	isen = (sels == 1);
	menu->SetAccMenu( InsertBefore,_("Wstaw &przed"))->Enable(isen);
	menu->SetAccMenu( InsertAfter,_("Wstaw p&o"))->Enable(isen);
	isen = (isen&&Kai->GetTab()->Video->GetState()!=None);
	menu->SetAccMenu( InsertBeforeVideo,_("Wstaw przed z &czasem wideo"))->Enable(isen);
	menu->SetAccMenu( InsertAfterVideo,_("Wstaw po z c&zasem wideo"))->Enable(isen);
	menu->SetAccMenu( InsertBeforeWithVideoFrame,_("Wstaw przed z czasem klatki wideo"))->Enable(isen);
	menu->SetAccMenu( InsertAfterWithVideoFrame,_("Wstaw po z czasem klatki wideo"))->Enable(isen);
	isen = (sels >0);
	menu->SetAccMenu( Duplicate,_("&Duplikuj linie"))->Enable(isen);
	isen = (sels == 2);
	menu->SetAccMenu( Swap,_("Za&mień"))->Enable(isen);
	isen = (sels >= 2&&sels <= 5);
	menu->SetAccMenu( Join,_("Złącz &linijki"))->Enable(isen);
	isen = (sels >= 2&&sels <= 50);
	menu->SetAccMenu( JoinToFirst,_("Złącz linijki zostaw pierwszą"))->Enable(isen);
	menu->SetAccMenu( JoinToLast,_("Złącz linijki zostaw ostatnią"))->Enable(isen);
	isen = (sels >0);
	menu->SetAccMenu( ContinousPrevious,_("Ustaw czasy jako ciągłe (poprzednia linijka)"))->Enable(isen);
	menu->SetAccMenu( ContinousNext,_("Ustaw czasy jako ciągłe (następna linijka)"))->Enable(isen);
	menu->SetAccMenu( Cut,_("Wytnij\tCtrl-X"))->Enable(isen);
	menu->SetAccMenu( Copy,_("Kopiuj\tCtrl-C"))->Enable(isen);
	menu->SetAccMenu( Paste,_("Wklej\tCtrl-V"));
	menu->SetAccMenu( CopyCollumns,_("Kopiuj kolumny"))->Enable(isen);
	menu->SetAccMenu( PasteCollumns,_("Wklej kolumny"));
	menu->Append(4444,_("Ukryj kolumny"),hidemenu);
	menu->SetAccMenu( NewFPS,_("Ustaw nowy FPS"));
	menu->SetAccMenu( FPSFromVideo,_("Ustaw FPS z wideo"))->Enable(Notebook::GetTab()->Video->GetState()!=None && sels==2);
	menu->SetAccMenu(PasteTranslation, _("Wklej tekst tłumaczenia"))->Enable(subsFormat<SRT && ((TabPanel*)GetParent())->SubsPath != "");
	menu->SetAccMenu( TranslationDialog,_("Okno przesuwania dialogów"))->Enable(showOriginal);
	menu->AppendSeparator();

	menu->SetAccMenu( RemoveText,_("Usuń tekst"))->Enable(isen);
	menu->SetAccMenu( Remove,_("Usuń"))->Enable(isen);
	menu->AppendSeparator();
	menu->SetAccMenu( FontCollectorID,_("Kolekcjoner czcionek"))->Enable(subsFormat<SRT);
	menu->SetAccMenu( SubsFromMKV,_("Wczytaj napisy z pliku MKV"))->Enable(Kai->GetTab()->VideoName.EndsWith(".mkv"));

	if(dummy){
		goto done;
	}
		
	int Modifiers=0;
	int id=menu->GetPopupMenuSelection(pos, this, &Modifiers);
	
	if(id<0){goto done;}
	
	if(Modifiers == wxMOD_SHIFT){
		if( id<=5000){goto done;}
		MenuItem *item=menu->FindItem(id);
		int ret=-1;
		wxString name=item->GetLabelText();
		ret=Hkeys.OnMapHkey(id, name, this, GRID_HOTKEY);
		if(ret!=-2){
			Hkeys.SetAccels();
			Hkeys.SaveHkeys();
		}
		goto done;
	}
	OnAccelerator(wxCommandEvent(wxEVT_COMMAND_MENU_SELECTED,id));
done:
	delete menu;
	VB->blockpaint=false;
}


void SubsGrid::OnInsertBefore()
{
	int rw=selarr[0];
	Selections.clear();
	Dialogue *dialog=CopyDial(rw, false);
	dialog->Text="";
	dialog->TextTl="";
	dialog->End=dialog->Start;
	if(rw>0 && GetDial(rw-1)->End > dialog->Start){
		dialog->Start=GetDial(rw-1)->End;
	}else{dialog->Start.Change(-4000);}
	InsertRows(rw, 1, dialog, false, true);
}

void SubsGrid::OnInsertAfter()
{
	int rw=selarr[0];
	Selections.clear();
	Dialogue *dialog=CopyDial(rw, false);
	dialog->Text="";
	dialog->TextTl="";
	dialog->Start=dialog->End;
	if(rw<GetCount()-1 && GetDial(rw+1)->End > dialog->Start){
		dialog->End=GetDial(rw+1)->Start;
	}else{dialog->End.Change(4000);}
	Edit->ebrow=rw+1;
	InsertRows(rw+1, 1, dialog, false, true);
}

void SubsGrid::OnDuplicate()
{
	int rw=selarr[0];
	//sel.clear();
	int rw1=rw+1;
	for(size_t i=1; i<selarr.GetCount(); i++){if(rw1==selarr[i]){rw1++;}else{break;} }
	int rw2=rw1-rw;
	std::vector<Dialogue *> dupl;
	for(int i=0; i<rw2; i++){

		dupl.push_back(file->CopyDial(i+rw,false));
		//sel.insert(i+rw1);

	}
	//Edit->ebrow=rw1;

	if(dupl.size()>0){
		InsertRows(rw1, dupl);
		dupl.clear();
	}
	SetModified(GRID_DUPLICATE, false);
	Refresh(false);
}


void SubsGrid::OnJoin(wxCommandEvent &event)
{
	wxString ntext;
	wxString ntltext;
	wxString en1;
	int idd=event.GetId();
	if(idd==JoinWithPrevious){
		if(Edit->ebrow==0){return;}
		selarr.Clear();
		selarr.Add(Edit->ebrow-1);
		selarr.Add(Edit->ebrow);
		en1=" ";
	}else if(idd==JoinWithNext){
		if(Edit->ebrow>=GetCount()||GetCount()<2){return;}
		selarr.Clear();
		selarr.Add(Edit->ebrow);
		selarr.Add(Edit->ebrow+1);
		en1=" ";
	}else{en1="\\N";}


	Dialogue *dialc = file->CopyDial(selarr[0]);
	Edit->ebrow=selarr[0];
	int start=INT_MAX, end=0;
	for(size_t i=0;i<selarr.size();i++)
	{
		wxString en=(i==0)?"":en1;
		Dialogue *dial=GetDial(selarr[i]);
		if(dial->Start.mstime < start){ start = dial->Start.mstime;}
		if(dial->End.mstime > end){	end = dial->End.mstime;}
		if(ntext==""){ntext=dial->Text;}
		else if(dial->Text!=""){ntext<<en<<dial->Text;}
		if(ntltext==""){ntltext=dial->TextTl;}
		else if(dial->TextTl!=""){ntltext<<en<<dial->TextTl;}
	}

	DeleteRow(selarr[1], selarr[selarr.size()-1]-selarr[1]+1);
	dialc->Start.NewTime(start);
	dialc->End.NewTime(end);
	dialc->Text=ntext;
	dialc->TextTl=ntltext;
	Selections.clear();
	file->edited=true;
	SpellErrors.clear();
	SetModified((idd==JoinWithPrevious)? GRID_JOIN_WITH_PREVIOUS : 
		(idd==JoinWithNext)? GRID_JOIN_WITH_NEXT : GRID_JOIN_LINES);
	RefreshColumns();
}

void SubsGrid::OnJoinToFirst(int id)
{

	Dialogue *dialc = file->CopyDial(selarr[0]);
	Dialogue *ldial = GetDial(selarr[selarr.size()-1]);
	dialc->End = ldial->End;

	if(id==JoinToLast){
		dialc->Text = ldial->Text;
		dialc->TextTl = ldial->TextTl;
	}
	Edit->ebrow=selarr[0];
	DeleteRow(selarr[1], selarr[selarr.size()-1]-selarr[1]+1);

	Selections.clear();
	Selections.insert(selarr[0]);
	SpellErrors.clear();
	SetModified((id==JoinToLast)? GRID_JOIN_TO_LAST : GRID_JOIN_TO_FIRST);
	RefreshColumns();
}


void SubsGrid::OnPaste(int id)
{

	int row=FirstSel();
	if(row < 0){wxBell();return;}
	int collumns = 0;
	if(id==PasteCollumns){
		int numCollumns = (hasTLMode) ? 11 : 10;
		wxString pasteText = (hasTLMode) ? _("Tekst do oryginału") : _("Tekst");
		wxString arr[11] = { _("Warstwa"), _("Czas początkowy"), _("Czas końcowy"), _("Aktor"), _("Styl"), _("Margines lewy"), _("Margines prawy"), _("Margines pionowy"), _("Efekt"), pasteText, _("Tekst do tłumaczenia") };
		int vals[11]={LAYER,START,END,ACTOR,STYLE,MARGINL,MARGINR,MARGINV,EFFECT,TXT,TXTTL};
		Stylelistbox slx(this, false, numCollumns, arr);
		int Selections = Options.GetInt(PasteCollumnsSelection);
		for (int j = 0; j < numCollumns; j++){
			if (Selections & vals[j]){
				Item * checkBox = slx.CheckListBox1->GetItem(j, 0);
				if (checkBox)
					checkBox->modified = true;
			}
		}
		if(slx.ShowModal()==wxID_OK)
		{
			for (size_t v=0;v<slx.CheckListBox1->GetCount();v++)
			{
				if(slx.CheckListBox1->GetItem(v,0)->modified){
					collumns |= vals[v];
				}
			}
			Options.SetInt(PasteCollumnsSelection, collumns);
			Options.SaveOptions();
		}else{return;}

	}else{
		Selections.clear();}
	Freeze();
	wxString whatpaste;
	if (wxTheClipboard->Open())
	{
		if (wxTheClipboard->IsSupported( wxDF_TEXT ))
		{
			wxTextDataObject data;
			wxTheClipboard->GetData( data );
			whatpaste = data.GetText();
		}
		wxTheClipboard->Close();
		if(whatpaste==""){Thaw();return;}
	}
	wxStringTokenizer wpaste(whatpaste,"\n", wxTOKEN_STRTOK);
	int cttkns=wpaste.CountTokens();
	int rws= (id==PasteCollumns)? 0 : row;
	std::vector<Dialogue*> tmpdial;
	wxString token;
	wxString tmptoken;
	while(wpaste.HasMoreTokens())
	{
		Dialogue *newdial=NULL;
		token = (tmptoken.empty())? wpaste.NextToken().Trim(false).Trim() : tmptoken;
		if(IsNumber(token)){
			token.Empty();
			while(wpaste.HasMoreTokens()){
				tmptoken = wpaste.NextToken().Trim(false).Trim();
				if(IsNumber(tmptoken)){break;}
				token += "\r\n" + tmptoken;
			}

		}
		newdial= new Dialogue(token);
		newdial->State=1;
		if(!newdial){continue;}
		//TODO przetestować czy wstawia poprawnie w text tłumaczenia
		if (collumns & TXTTL){ 
			newdial->TextTl = newdial->Text; 
		}
		if(newdial->Form!=subsFormat){newdial->Conv(subsFormat);}
		if(newdial->NonDialogue){newdial->NonDialogue=false; newdial->IsComment=false;}
		if(id==Paste){
			tmpdial.push_back(newdial);
			Selections.insert(rws);
		}else{
			if(rws<(int)selarr.GetCount()/* && selarr[rws] < GetCount()*/){
				ChangeCell(collumns, selarr[rws],newdial);
			}
			delete newdial;
		}
		rws++;
	}

	if(tmpdial.size()>0){
		InsertRows(row, tmpdial,true);
	}
	if(Selections.size()!=0){
		Edit->ebrow = *Selections.begin();}
	scPos+=cttkns;
	SetModified((id==Paste)? GRID_PASTE : GRID_PASTE_COLLUMNS);
	Thaw();
	RefreshColumns();
}

void SubsGrid::CopyRows(int id)
{
	int cols=0;
	if(id==CopyCollumns){
		wxString arr[ ]={_("Warstwa"),_("Czas początkowy"),_("Czas końcowy"),_("Aktor"),_("Styl"),_("Margines lewy"),_("Margines prawy"),_("Margines pionowy"),_("Efekt"),_("Tekst"),_("Tekst bez tagów")};
		int vals[ ]={LAYER,START,END,ACTOR,STYLE,MARGINL,MARGINR,MARGINV,EFFECT,TXT,TXTTL};
		Stylelistbox slx(this,false,11,arr);
		int Selections = Options.GetInt(CopyCollumnsSelection);
		for (int j = 0; j < 11; j++){
			if (Selections & vals[j]){
				Item * checkBox = slx.CheckListBox1->GetItem(j, 0);
				if (checkBox)
					checkBox->modified = true;
			}
		}
		if(slx.ShowModal()==wxID_OK)
		{
			for (size_t v=0;v<slx.CheckListBox1->GetCount();v++)
			{

				if(slx.CheckListBox1->GetItem(v,0)->modified){
					cols|= vals[v];
				}
			}
			Options.SetInt(CopyCollumnsSelection, cols);
			Options.SaveOptions();
		}else{return;}

	}
	selarr=GetSels();
	wxString whatcopy;
	for(size_t i=0; i<selarr.GetCount();i++)
	{	
		if(id!=CopyCollumns){
			//tłumaczenie ma pierwszeństwo w kopiowaniu
			GetDial(selarr[i])->GetRaw(&whatcopy, hasTLMode && GetDial(selarr[i])->TextTl!="");
		}else{
			whatcopy<<GetDial(selarr[i])->GetCols(cols,hasTLMode && GetDial(selarr[i])->TextTl!="");
		}
	}
	if (wxTheClipboard->Open())
	{
		wxTheClipboard->SetData( new wxTextDataObject(whatcopy) );
		wxTheClipboard->Close();
		wxTheClipboard->Flush();
	}
}

void SubsGrid::OnInsertBeforeVideo(bool frameTime)
{
	int rw=selarr[0];
	Selections.erase(Selections.find(rw));
	Dialogue *dialog=CopyDial(rw, false);
	if(!frameTime){
		dialog->Text="";
		dialog->TextTl="";
	}
	int time=Kai->GetTab()->Video->GetFrameTime();
	dialog->Start.NewTime(time);
	dialog->End.NewTime(frameTime? Kai->GetTab()->Video->GetFrameTime(false) : time+4000);
	InsertRows(rw, 1, dialog, false, true);
}

void SubsGrid::OnInsertAfterVideo(bool frameTime)
{
	int rw=selarr[0];
	Selections.erase(Selections.find(rw));
	Dialogue *dialog=CopyDial(rw, false);
	if(!frameTime){
		dialog->Text="";
		dialog->TextTl="";
	}
	int time=Kai->GetTab()->Video->GetFrameTime();
	dialog->Start.NewTime(time);
	dialog->End.NewTime(frameTime? Kai->GetTab()->Video->GetFrameTime(false) : time+4000);
	Edit->ebrow=rw+1;
	InsertRows(rw+1, 1, dialog, false, true);
}


void SubsGrid::OnAccelerator(wxCommandEvent &event)
{
	int id=event.GetId();
	VideoCtrl *vb=Kai->GetTab()->Video;
	selarr = GetSels();
	int sels=selarr.GetCount();
	bool hasVideo = vb->GetState() != None;
	switch(id){
		case PlayPause: if(vb->IsShown()){vb->Pause();} break;
		case Plus5Second: vb->Seek(vb->Tell()+5000); break;
		case Minus5Second: vb->Seek(vb->Tell()-5000); break;
		case InsertBeforeVideo: 
		case InsertBeforeWithVideoFrame: 
			if(sels>0 && hasVideo) OnInsertBeforeVideo(id == InsertBeforeWithVideoFrame); break;
		case InsertAfterVideo: 
		case InsertAfterWithVideoFrame: 
			if(sels>0 && hasVideo) OnInsertAfterVideo(id == InsertAfterWithVideoFrame); break;
		case InsertBefore: if(sels>0) OnInsertBefore(); break;
		case InsertAfter: if(sels>0) OnInsertAfter(); break;
		case Duplicate: if(sels>0) OnDuplicate(); break;
		case Copy: 
		case CopyCollumns: if(sels>0) CopyRows(id); break;
		case Cut: if(sels>0) CopyRows(id);DeleteRows(); break;
		case Paste: 
		case PasteCollumns: if(sels>0) OnPaste(id); break;
		case Remove: if(sels>0) DeleteRows(); break;
		case RemoveText: if(sels>0) DeleteText(); break;
		case ContinousPrevious: 
		case ContinousNext: if(sels>0) OnMakeContinous(id); break;
		case Swap: if(sels==2){SwapRows(selarr[0],selarr[1],true);} break;
		case FPSFromVideo: if( hasVideo && sels==2){OnSetFPSFromVideo();} break;
		case Join: if(sels>1){OnJoin(event);} break;
		case JoinToFirst:
		case JoinToLast: if(sels>1){OnJoinToFirst(id);} break;
		case PasteTranslation: if(subsFormat<SRT && ((TabPanel*)GetParent())->SubsPath!=""){OnPasteTextTl();} break;
		case SubsFromMKV: if( Kai->GetTab()->VideoName.EndsWith(".mkv")){OnMkvSubs(event);} break;
		case NewFPS: OnSetNewFPS(); break;
		default:
			break;
	}
	
	if(id==TranslationDialog && showOriginal){
		static TLDialog *tld= new TLDialog(this,this);
		tld->Show();
	}
	else if(id>6000){
		Kai->OnMenuSelected(event);
	}
	/*else if(id>5000 && id<5555){
		int id5000=(id-5000);
		if(visible & id5000){visible ^= id5000;}
		else{visible |= id5000;}
		SpellErrors.clear();
		Options.SetInt("Grid Hide Collums", visible);
		RefreshColumns();
	}*/
}


void SubsGrid::OnPasteTextTl()
{
	wxFileDialog *FileDialog1 = new wxFileDialog(this, _("Wybierz plik napisów"), Kai->GetTab()->SubsPath.BeforeLast('\\'), "", _("Pliki napisów (*.ass),(*.srt),(*.sub),(*.txt)|*.ass;*.srt;*.sub;*.txt"), wxFD_OPEN|wxFD_FILE_MUST_EXIST, wxDefaultPosition, wxDefaultSize, "wxFileDialog");
	if (FileDialog1->ShowModal() == wxID_OK){
		OpenWrite op;
		wxString pathh=FileDialog1->GetPath();
		wxString txt;
		if(!op.FileOpen(pathh, &txt)){return;}
		wxString ext=pathh.AfterLast('.');
		int iline=0;

		//for(int i=0;i<GetCount();i++){file->subs.dials[i]->spells.Clear();}

		if(ext=="srt"){
			//wxString dbg;
			wxStringTokenizer tokenizer(txt,"\n",wxTOKEN_STRTOK);
			tokenizer.GetNextToken();
			wxString text1;
			while ( tokenizer.HasMoreTokens() )
			{
				wxString text=tokenizer.GetNextToken().Trim();
				if(IsNumber(text)){if(text1!=""){
					//dbg<<text1<<"\n";
					//dbg<<ndl.Start.raw<<" x "<<ndl.End.raw<<" x "<<ndl.Text<<"\n"; 
					Dialogue diall=Dialogue(text1.Trim());
					if(iline<GetCount()){
						diall.Conv(subsFormat);
						CopyDial(iline)->TextTl=diall.Text;
					}
					else{
						diall.Conv(subsFormat);
						diall.Start.NewTime(0);
						diall.End.NewTime(0);
						diall.Style=GetSInfo("TLMode Style");
						diall.TextTl=diall.Text;
						diall.Text="";
						AddLine(diall.Copy());
					}
					iline++;text1="";}}
				else{text1<<text<<"\r\n";}

			}
		}else{

			wxStringTokenizer tokenizer(txt,"\n",wxTOKEN_STRTOK);
			while ( tokenizer.HasMoreTokens() )
			{
				wxString token = tokenizer.GetNextToken();
				if(!(ext=="ass" && !token.StartsWith("Dialogue"))){  
					Dialogue diall=Dialogue(token);
					if(iline<GetCount()){
						diall.Conv(subsFormat);
						CopyDial(iline)->TextTl=diall.Text;}
					else{
						diall.Conv(subsFormat);
						diall.Start.NewTime(0);
						diall.End.NewTime(0);
						diall.Style=GetSInfo("TLMode Style");
						diall.TextTl=diall.Text;
						diall.Text="";
						AddLine(diall.Copy());
					}
					iline++;}	   
			}
		}



		Edit->SetTl(true);
		SetTlMode(true);
		AddSInfo("TLMode Showtl", "Yes");
		showOriginal=true;
		//Edit->SetIt(Edit->ebrow);
		SetModified(GRID_PASTE_TRANSLATION);
		Refresh(false);
	}
	FileDialog1->Destroy();
}

void SubsGrid::MoveTextTL(char mode)
{

	wxArrayInt selecs=GetSels(true);
	
	if(selecs.GetCount()<1||!showOriginal||!hasTLMode) return;
	int first=selecs[0];
	int mrow=1;
	if(selecs.GetCount()>1){
		mrow=selecs[1]-first;
	}
	
	if(mode<3){// w górę ^
		//tryb 2 gdzie dodaje puste linijki a tekst pl pozostaje bez zmian
		if(mode==2){
			Dialogue *insdial =GetDial(first)->Copy();
			insdial->Text="";
			InsertRows(first, mrow, insdial);
		}
		Selections.insert(first);
		for(int i=first; i<GetCount(); i++)
		{
			if(i<first+mrow){
				//tryb1 gdzie łączy wszystkie nachodzące linijki w jedną
				if(mode==1){
					wxString mid=(GetDial(first)->TextTl!="" && GetDial(i+1)->TextTl!="")?"\\N":"";
					CopyDial(first)->TextTl << mid << GetDial(i+1)->TextTl;
					if(i!=first){CopyDial(i)->TextTl = GetDial(i+mrow)->TextTl;}
				}else if(i+mrow<GetCount()){
					CopyDial(i)->TextTl = GetDial(i+mrow)->TextTl;
				}
			}
			else if(i<GetCount()-mrow){
				CopyDial(i)->TextTl = GetDial(i+mrow)->TextTl;}
			else if(GetDial(i)->Text!=""){/*wxLogStatus("onlytl mrow--");*/mrow--;}

		}
		
		if(mrow>0){
			DeleteRow(GetCount()-mrow, mrow);
		}

	}else{//w dół v
		int oldgc=GetCount();
		Dialogue diall;
		diall.End.NewTime(0);
		diall.Style=GetSInfo("TLMode Style");
		for(int i=0; i<mrow; i++)
		{
			AddLine(diall.Copy());
		}

		bool onlyo=true;
		//sel.insert(first+mrow);
		for(int i=GetCount()-1; i>=first; i--)
		{
			if(i<first+mrow){
				if(mode==3){
					CopyDial(i)->TextTl="";}
				else if(mode==4||mode==5){
					if(mode==4){if(onlyo){CopyDial(first+mrow)->Start = GetDial(first)->Start; onlyo=false;}
					CopyDial(first+mrow)->Text.Prepend(GetDial(i)->Text+"\\N");mrow--;}
					DeleteRow(i);
				}
			}
			else{
				CopyDial(i)->TextTl = GetDial(i-mrow)->TextTl;}


		}

	}
	SetModified(GRID_TRANSLATION_TEXT_MOVE,true);
	Refresh(false);

}


void SubsGrid::OnMkvSubs(wxCommandEvent &event)
{
	int idd=event.GetId();
	if(Modified){
		int wbutton=KaiMessageBox(_("Zapisać plik przed wczytaniem napisów z MKV?"), 
			_("Potwierdzenie"),wxICON_QUESTION | wxYES_NO |wxCANCEL, this);
		if (wbutton==wxYES){Kai->Save(false);}
		else if(wbutton==wxCANCEL){return;}}
	wxString mkvpath;
	if(idd==SubsFromMKV)
	{
		mkvpath=Kai->GetTab()->VideoPath;
	}
	else{
		mkvpath=event.GetString();
	}

	
	MatroskaWrapper mw;
	if(!mw.Open(mkvpath,false)){return;}
	int isgood = (int)mw.GetSubtitles(this);
	mw.Close();
	

	if(isgood){
		if(hasTLMode){Edit->SetTl(false); hasTLMode=false;showOriginal=false;Kai->Menubar->Enable(SaveTranslation,false);}
		SetSubsForm();
		wxString ext=(subsFormat<SRT)?"ass" : "srt";
		if(subsFormat<SRT){Edit->TlMode->Enable();}else{Edit->TlMode->Enable(false);}

		Kai->GetTab()->SubsPath=mkvpath.BeforeLast('.')+_(" napisy.")+ext;
		Kai->GetTab()->SubsName=Kai->GetTab()->SubsPath.AfterLast('\\');
		//Kai->SetRecent();
		Kai->UpdateToolbar();
		Edit->RefreshStyle(true);

		Kai->Label();
		if(subsFormat==ASS){
			wxString katal=GetSInfo("Last Style Storage");

			if(katal!=""){
				for(size_t i=0;i<Options.dirs.size();i++){
					if(katal==Options.dirs[i]){Options.LoadStyles(katal);}
				}
			}


		}
		if(Kai->GetTab()->Video->GetState()!=None){Kai->GetTab()->Video->OpenSubs(SaveText(),true,true);
			if(!isgood){KaiMessageBox(_("Otwieranie napisów nie powiodło się"), _("Uwaga"));}
			if(Kai->GetTab()->Video->GetState()==Paused){Kai->GetTab()->Video->Render();}
		}

		if(!Kai->GetTab()->edytor&&!Kai->GetTab()->Video->isFullscreen){Kai->HideEditor();}
		Kai->GetTab()->CTime->Contents();
		Selections.insert(Edit->ebrow);
		RefreshColumns();
		Edit->HideControls();
		if(StyleStore::HasStore() && subsFormat==ASS){StyleStore::Get()->LoadAssStyles();}
		Kai->SetSubsResolution(!Options.GetBool(DontAskForBadResolution));
	}
	
}


<<<<<<< HEAD
=======
	SaveFile(*path, false, true);
>>>>>>> master

void SubsGrid::ResizeSubs(float xnsize, float ynsize, bool stretch)
{
<<<<<<< HEAD
	float val=xnsize;
	float val1=ynsize;
	float valFscx=1.f;
	float vectorXScale = xnsize;
	int resizeScale = 0;
	if(ynsize!=xnsize){
		if(ynsize>xnsize){
			resizeScale = (stretch)? 1 : 0;
			valFscx = (stretch)? (xnsize/ynsize) : 1.f;
		}else{
			val = ynsize;
			val1 = xnsize;
			resizeScale = (stretch)? 1 : 0;
			valFscx = (stretch)? (ynsize/xnsize) : 1.f;
		}
		if(stretch){vectorXScale /= valFscx;}
	}


	for(int i=0;i<StylesSize();i++){
		Styles *resized= file->CopyStyle(i);
		int ml=wxAtoi(resized->MarginL);
		ml*=xnsize;
		resized->MarginL="";
		resized->MarginL<<ml;
		int mr=wxAtoi(resized->MarginR);
		mr*=xnsize;
		resized->MarginR="";
		resized->MarginR<<mr;
		int mv=wxAtoi(resized->MarginV);
		mv*=ynsize;
		resized->MarginV="";
		resized->MarginV<<mv;
		if(resizeScale==1){
			double fscx=100;
			resized->ScaleX.ToCDouble(&fscx);
			fscx*=valFscx;
			resized->ScaleX=getfloat(fscx);
		}
		double fs=0;
		resized->Fontsize.ToCDouble(&fs);
		fs*=val1;
		resized->Fontsize=getfloat(fs);
		double ol=0;
		resized->Outline.ToCDouble(&ol);
		ol*=val;
		resized->Outline=getfloat(ol);
		double sh=0;
		resized->Shadow.ToCDouble(&sh);
		sh*=val;
		resized->Shadow=getfloat(sh);
		double fsp=0;
		resized->Spacing.ToCDouble(&fsp);
		fsp*=val;
		resized->Spacing=getfloat(fsp);
	}

	//dialogi, największy hardkor, wszystkie tagi zależne od rozdzielczości trzeba zmienić
	//tu zacznie się potęga szukaczki tagów
	//wxRegEx onenum("\\\\(fax|fay|fs|bord|shad|pos|move|iclip|clip|org)([^\\\\}\\)]*)",wxRE_ADVANCED);
	//wxRegEx drawing("\\\\p([0-9]+)[\\\\}\\)]",wxRE_ADVANCED);
	wxString tags[] = {"pos","move","bord","shad","org","fsp","fscx","fs","clip","iclip","p","xbord","ybord","xshad","yshad"};

	for(int i=0;i<GetCount();i++){
		//zaczniemy od najłatwiejszego, marginesy

		Dialogue *diall=GetDial(i);
		if(diall->IsComment){continue;}
		diall=diall->Copy();
		bool marginChanged=false;
		bool textChanged=false;
		if(diall->MarginL){diall->MarginL*=xnsize; marginChanged=true;}
		if(diall->MarginR){diall->MarginR*=xnsize; marginChanged=true;}
		if(diall->MarginV){diall->MarginV*=ynsize; marginChanged=true;}

		wxString txt=(diall->TextTl != "")? diall->TextTl : diall->Text;
		/*long long replaceMismatch = 0;*/
		size_t pos=0;
		
		diall->ParseTags(tags, 15, false);
		ParseData *pdata = diall->parseData;
		if(!pdata){continue;}
		size_t tagsSize = pdata->tags.size();
		//if(tagsSize < 1){continue;}
		//pętla tagów
		int j = tagsSize-1;
		while(j >= 0){
			TagData *tag = pdata->tags[j--];
			size_t tagValueLen = tag->value.Len();
			pos = tag->startTextPos;
			double tagValue=0.0;
			int ii=0;
			wxString resizedTag;
			if(tag->tagName != "fsp" && tag->tagName.EndsWith('p') && tag->value.find('m') != -1){
				int mPos = tag->value.find('m');
				resizedTag = tag->value.Left(mPos) + "m ";
				wxStringTokenizer tknzr(tag->value.AfterFirst('m')," ",wxTOKEN_STRTOK);
				/*if(tag->tagName.EndsWith("clip")){
					wxLogStatus(tag->value);
				}*/
				float xscale = (tag->tagName == "p")? vectorXScale : xnsize;

				while(tknzr.HasMoreTokens()){
					wxString tkn=tknzr.NextToken();
					if(tkn!="m" && tkn!="l" && tkn !="b" && tkn != "s" && tkn != "c"){
						wxString lastC;
						if(tkn.EndsWith("c")){
							tkn.RemoveLast(1);
							lastC="c";
						}
						if(tkn.ToCDouble(&tagValue)){
							tagValue*=(ii%2==0)? xscale : ynsize;
							resizedTag<<getfloat(tagValue)<<lastC<<" ";
						}else{
							wxLogMessage(_("W linii %i nie można przeskalować wartości '%s'\nw tagu '%s'"), i+1, tkn, tag->tagName);
							resizedTag<<tkn<<lastC<<" ";
						}
										
						ii++;
					}else{
						resizedTag<<tkn<<" ";
					}
				}
				resizedTag.Trim();
			}else if(tag->multiValue){
				wxStringTokenizer tknzr(tag->value,",",wxTOKEN_STRTOK);
				while(tknzr.HasMoreTokens()){
					wxString tkn=tknzr.NextToken();
					tkn.Trim();
					tkn.Trim(false);

					if(ii<4 && tkn.ToCDouble(&tagValue))
					{
						tagValue *= (ii % 2 == 0)? xnsize : ynsize;
						resizedTag<<getfloat(tagValue)<<",";
						ii++;
					}
					else
					{
						if(ii<4){
							wxLogMessage(_("W linii %i nie można przeskalować wartości '%s'\nw tagu '%s'"), i+1, tkn, tag->tagName);
						}
						resizedTag<<tkn<<",";
						ii++;
					}
				}
				resizedTag = resizedTag.BeforeLast(',');

			}else if(tag->tagName != "p"){
				if(tag->value.ToCDouble(&tagValue)){
					tagValue *= (tag->tagName == "fscx")? valFscx : 
						(tag->tagName == "fs")? val1 :
						(tag->tagName.StartsWith('x'))? xnsize : 
						(tag->tagName.StartsWith('y'))? ynsize : val;
					resizedTag = getfloat(tagValue);
				}else{
					wxLogMessage(_("W linii %i nie można przeskalować wartości '%s'\nw tagu '%s'"), i+1, tag->value, tag->tagName);
					resizedTag = tag->value;
				}
=======
	TabPanel *pan=(TabPanel*)GetParent();
	int _time=pan->Video->Tell();
	bool toEnd = pan->Video->GetState() == Playing;
	wxString *txt=new wxString();
	if(form== ASS){
		(*txt)<<"[Script Info]\r\n"<<GetSInfos(false);
		(*txt)<<"\r\n[V4+ Styles]\r\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding \r\n";
		(*txt)<<GetStyles(false);
		(*txt)<<" \r\n[Events]\r\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\r\n";
	}
	Edit->Send(EDITBOX_LINE_EDITION, false, true);
	if(_time >= Edit->line->Start.mstime && _time < Edit->line->End.mstime)
	{
		if(visible){*visible=true;}
	}else if(visible){
		*visible=false;
	}
	bool noLine = true;
	bool isTlmode = GetSInfo("TLMode")=="Yes";
	wxString tlStyle = GetSInfo("TLMode Style");
	for(int i=0; i<GetCount(); i++){
		Dialogue *dial=GetDial(i);
		if(i==Edit->ebrow){ 
			dial = Edit->line;
		}
		if(selected && sel.find(i)!=sel.end()){
			selected->Add(txt->Len());
			continue;
		}
		if((toEnd && _time <= dial->Start.mstime) || (_time >= dial->Start.mstime && _time < dial->End.mstime)){
			//if(trimSels && sel.find(i)!=sel.end()){continue;}
			if( isTlmode && dial->TextTl!=""){
				dial->GetRaw(txt, false, tlStyle);
				dial->GetRaw(txt, true);
>>>>>>> master
			}else{
				continue;
			}
			/*replaceMismatch += (tagValueLen - resizedTag.Len());*/
			txt.replace(pos, tagValueLen, resizedTag);
			textChanged = true;
		}
			
		if(marginChanged || textChanged){
			if(textChanged){
				if(SpellErrors.size() >= (size_t)i) SpellErrors[i].clear();
				if(diall->TextTl != ""){
					diall->TextTl=txt;
				}else{
					diall->Text=txt;
				}
			}
			file->GetSubs()->ddials.push_back(diall);
			file->GetSubs()->dials[i]=diall;
			diall->ClearParse();
		}else{
			delete diall;
		}
		
	}
	
	//Refresh(false);
}

void SubsGrid::OnMakeContinous(int idd)
{
	wxArrayInt sels=GetSels();
	if(sels.size()<0){wxBell();return;}
	if(idd==ContinousPrevious){
		
		/*int diff=GetDial(fs)->End.mstime - GetDial(fs-1)->Start.mstime;*/
		for(size_t i=0; i < sels.size(); i++)
		{
			if(sels[i]<1){continue;}
			CopyDial(sels[i])->Start = GetDial(sels[i]-1)->End;
		}
	}
<<<<<<< HEAD
	else
	{
		int dialsize = GetCount()-1;
		for(size_t i=0; i < sels.size(); i++)
		{
			if(sels[i]>=dialsize){continue;}
			CopyDial(sels[i])->End = GetDial(sels[i]+1)->Start;
=======
	if(noLine){
		if (form == ASS){
			Dialogue().GetRaw(txt);
		}
		else{
			delete txt;
			return NULL;
>>>>>>> master
		}
	}
	SetModified(GRID_MAKE_LINES_CONTINUES);
	Refresh(false);
}

void SubsGrid::ConnectAcc(int id)
{
	Connect(id,wxEVT_COMMAND_MENU_SELECTED,(wxObjectEventFunction)&SubsGrid::OnAccelerator);
}

void SubsGrid::OnSetFPSFromVideo()
{
	if(selarr.size()!=2){return;}
	Dialogue *first=GetDial(selarr[0]);
	Dialogue *second=GetDial(selarr[1]);
	int firstTime=first->Start.mstime;
	int secondTime=second->Start.mstime;
	int videoTime=Notebook::GetTab()->Video->Tell();
	float diffVideo = (videoTime-secondTime);
	float diffLines = (secondTime-firstTime);

	for (int i=0;i<GetCount();i++){
		Dialogue *dialc=CopyDial(i);
		dialc->Start.Change(diffVideo *((dialc->Start.mstime - firstTime) / diffLines));
		dialc->End.Change(diffVideo *((dialc->End.mstime - firstTime) / diffLines));
	}
	SetModified(GRID_SET_VIDEO_FPS);
	if(subsFormat>TMP){RefreshColumns(START|END);}else{Refresh(false);}
}

class fpsdial : public KaiDialog
{
public:
	fpsdial(wxWindow *parent)
		:KaiDialog(parent,-1,_("Wybierz nowy FPS"))
	{
		DialogSizer* siz = new DialogSizer(wxHORIZONTAL);
		wxFlexGridSizer *sizer=new wxFlexGridSizer(2,2,2);
		wxArrayString fpsy;
		wxTextValidator valid(wxFILTER_INCLUDE_CHAR_LIST);
		wxArrayString includes;
		includes.Add("0");
		includes.Add("1");
		includes.Add("2");
		includes.Add("3");
		includes.Add("4");
		includes.Add("5");
		includes.Add("6");
		includes.Add("7");
		includes.Add("8");
		includes.Add("9");
		includes.Add(".");
		valid.SetIncludes(includes);

		fpsy.Add("23.976");fpsy.Add("24");fpsy.Add("25");fpsy.Add("29.97");fpsy.Add("30");fpsy.Add("60");
		oldfps=new KaiChoice(this,-1,"",wxDefaultPosition,wxDefaultSize,fpsy,0,valid);
		oldfps->SetSelection(0);
		newfps=new KaiChoice(this,-1,"",wxDefaultPosition,wxSize(80,-1),fpsy,0,valid);
		newfps->SetSelection(2);
		sizer->Add(new KaiStaticText(this,-1,_("FPS napisów")),0,wxALIGN_CENTER_VERTICAL|wxALL,4);
		sizer->Add(oldfps,0,wxEXPAND|wxALL,4);
		sizer->Add(new KaiStaticText(this,-1,_("Nowy FPS napisów")),0,wxALIGN_CENTER_VERTICAL|wxALL,4);
		sizer->Add(newfps,0,wxEXPAND|wxALL,4);
		MappedButton *ok=new MappedButton(this,15555,_("Zmień fps"));
		Connect(15555,wxEVT_COMMAND_BUTTON_CLICKED,(wxObjectEventFunction)&fpsdial::OkClick);
		MappedButton *cancel=new MappedButton(this,wxID_CANCEL,_("Anuluj"));
		sizer->Add(ok,0,wxEXPAND|wxALL,4);
		sizer->Add(cancel,0,wxEXPAND|wxALL,4);
		siz->Add(sizer, 0, wxEXPAND);
		SetSizerAndFit(siz);
		CenterOnParent();
	}
	virtual ~fpsdial(){};
	void OkClick(wxCommandEvent &evt)
	{

		if(oldfps->GetValue().ToDouble(&ofps) && newfps->GetValue().ToDouble(&nfps)){
			EndModal(1);
		}else{KaiMessageBox(_("Niewłaściwy fps"));}
	}
	double ofps,nfps;
	KaiChoice *oldfps;
	KaiChoice *newfps;
};

void SubsGrid::OnSetNewFPS()
{
	fpsdial nfps(this);
	if(nfps.ShowModal()==1){
		double sub = nfps.ofps / nfps.nfps;

		for (int i=0;i<GetCount();i++){
			Dialogue *dialc=CopyDial(i);
			dialc->Start.NewTime(dialc->Start.mstime*sub);
			dialc->End.NewTime(dialc->End.mstime*sub);
		}
		SetModified(GRID_SET_CUSTOM_FPS);
		if(subsFormat>TMP){RefreshColumns(START|END);}else{Refresh(false);}
	}
}

class SwapPropertiesDialog :public KaiDialog
{
public:
	SwapPropertiesDialog(wxWindow *parent)
		:KaiDialog(parent,-1, _("Potwierdzenie"))
	{
		DialogSizer *main = new DialogSizer(wxVERTICAL);
		const int numFields = 6;
		wxString fieldNames[numFields] = {_("Tytuł"), _("Autor"), _("Tłumaczenie"), _("Korekta"), _("Timing"), _("Edycja")};
		CONFIG fieldOnValues[numFields] = {ASSPropertiesTitleOn, ASSPropertiesScriptOn, ASSPropertiesTranslationOn, 
			ASSPropertiesEditingOn, ASSPropertiesTimingOn, ASSPropertiesUpdateOn};
		for(int i = 0; i < numFields; i++){
			fields[i] = new KaiCheckBox(this, -1, fieldNames[i]);
			fields[i]->SetValue(Options.GetBool(fieldOnValues[i]));
			main->Add(fields[i], 0, wxEXPAND|wxALL, 3);
		}
		wxBoxSizer *buttons = new wxBoxSizer(wxHORIZONTAL);
		MappedButton *Ok = new MappedButton(this, wxID_OK, "OK");
		MappedButton *Cancel = new MappedButton(this, wxID_CANCEL, _("Anuluj"));
		MappedButton *TurnOf = new MappedButton(this, 19921, _("Wyłącz potwierdzenie"));
		Bind(wxEVT_COMMAND_BUTTON_CLICKED, [=](wxCommandEvent &evt){
			Options.SetBool(ASSPropertiesAskForChange, false);
			Options.SaveOptions(true,false);
			EndModal(19921);
		}, 19921);
		buttons->Add(Ok, 1, wxALL, 4);
		buttons->Add(Cancel, 1, wxALL, 4);
		buttons->Add(TurnOf, 0, wxALL, 4);
		main->Add(buttons);
		SetSizerAndFit(main);
		CenterOnParent();
	}
	virtual ~SwapPropertiesDialog(){};
	void SaveValues(){
		const int numFields = 6;
		CONFIG fieldOnValues[numFields] = {ASSPropertiesTitleOn, ASSPropertiesScriptOn, ASSPropertiesTranslationOn, 
			ASSPropertiesEditingOn, ASSPropertiesTimingOn, ASSPropertiesUpdateOn};
		for(int i = 0; i < numFields; i++){
			Options.SetBool(fieldOnValues[i], fields[i]->GetValue());
		}
	}
private:
	KaiCheckBox *fields[6];
};

bool SubsGrid::SwapAssProperties()
{
	const int numFields = 6;
	CONFIG fieldOnValues[numFields] = {ASSPropertiesTitleOn, ASSPropertiesScriptOn, ASSPropertiesTranslationOn, 
		ASSPropertiesEditingOn, ASSPropertiesTimingOn, ASSPropertiesUpdateOn};
	CONFIG fieldValues[numFields] = {ASSPropertiesTitle, ASSPropertiesScript, ASSPropertiesTranslation, 
		ASSPropertiesEditing, ASSPropertiesTiming, ASSPropertiesUpdate};
	wxString fieldNames[numFields] = {"Title", "Original Script", "Original Translation", 
		"Original Editing", "Original Timing", "Script Updated By"};
	if(Options.GetBool(ASSPropertiesAskForChange)){
		bool hasSomethingToChange = false;
		for(int i = 0; i < numFields; i++){
			if(Options.GetBool(fieldOnValues[i])){
				if(GetSInfo(fieldNames[i]) != Options.GetString(fieldValues[i])){
					hasSomethingToChange = true;
					break;
				}
			}
		}
		if(!hasSomethingToChange){return false;}
		SwapPropertiesDialog SPD(Kai);
		int id = SPD.ShowModal();
		if(id == wxID_OK){
			SPD.SaveValues();
		}else if(id == 19921){
			return false;
		}else{
			return true;
		}
	}
	
	for(int i = 0; i < numFields; i++){
		if(Options.GetBool(fieldOnValues[i])){
			AddSInfo(fieldNames[i],Options.GetString(fieldValues[i]));
		}
	}
	return false;
}


BEGIN_EVENT_TABLE(SubsGrid, SubsGridBase)
	EVT_MENU(Cut,SubsGrid::OnAccelerator)
	EVT_MENU(Copy,SubsGrid::OnAccelerator)
	EVT_MENU(Paste,SubsGrid::OnAccelerator)
END_EVENT_TABLE()